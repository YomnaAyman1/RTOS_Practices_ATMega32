
rtos-mutex-lcd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000017fa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00800060  000017fa  0000188e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002c5  00800090  00800090  000018be  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000018be  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000018f0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000390  00000000  00000000  0000192c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004e74  00000000  00000000  00001cbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001109  00000000  00000000  00006b30  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002987  00000000  00000000  00007c39  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b00  00000000  00000000  0000a5c0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000015db  00000000  00000000  0000b0c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004a61  00000000  00000000  0000c69b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000410  00000000  00000000  000110fc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9c 03 	jmp	0x738	; 0x738 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea ef       	ldi	r30, 0xFA	; 250
      68:	f7 e1       	ldi	r31, 0x17	; 23
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 39       	cpi	r26, 0x90	; 144
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	23 e0       	ldi	r18, 0x03	; 3
      78:	a0 e9       	ldi	r26, 0x90	; 144
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 35       	cpi	r26, 0x55	; 85
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 4f 01 	call	0x29e	; 0x29e <main>
      8a:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <send_enable>:
	column--;
	send_command((0x80 + 0x40 * row)+ column );
	_delay_ms(1);
	send_data(out_char);
	_delay_ms(1);
}
      92:	a8 9a       	sbi	0x15, 0	; 21
      94:	00 c0       	rjmp	.+0      	; 0x96 <send_enable+0x4>
      96:	a8 98       	cbi	0x15, 0	; 21
      98:	00 c0       	rjmp	.+0      	; 0x9a <send_enable+0x8>
      9a:	08 95       	ret

0000009c <send_command>:
      9c:	a9 98       	cbi	0x15, 1	; 21
      9e:	18 ba       	out	0x18, r1	; 24
      a0:	88 bb       	out	0x18, r24	; 24
      a2:	0e 94 49 00 	call	0x92	; 0x92 <send_enable>
      a6:	08 95       	ret

000000a8 <send_data>:
      a8:	a9 9a       	sbi	0x15, 1	; 21
      aa:	18 ba       	out	0x18, r1	; 24
      ac:	88 bb       	out	0x18, r24	; 24
      ae:	0e 94 49 00 	call	0x92	; 0x92 <send_enable>
      b2:	08 95       	ret

000000b4 <Lcd_Init>:
      b4:	a1 9a       	sbi	0x14, 1	; 20
      b6:	a0 9a       	sbi	0x14, 0	; 20
      b8:	8f ef       	ldi	r24, 0xFF	; 255
      ba:	87 bb       	out	0x17, r24	; 23
      bc:	a9 98       	cbi	0x15, 1	; 21
      be:	a8 98       	cbi	0x15, 0	; 21
      c0:	18 ba       	out	0x18, r1	; 24
      c2:	87 e8       	ldi	r24, 0x87	; 135
      c4:	93 e1       	ldi	r25, 0x13	; 19
      c6:	01 97       	sbiw	r24, 0x01	; 1
      c8:	f1 f7       	brne	.-4      	; 0xc6 <Lcd_Init+0x12>
      ca:	00 c0       	rjmp	.+0      	; 0xcc <Lcd_Init+0x18>
      cc:	00 00       	nop
      ce:	18 ba       	out	0x18, r1	; 24
      d0:	88 e3       	ldi	r24, 0x38	; 56
      d2:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
      d6:	0e 94 49 00 	call	0x92	; 0x92 <send_enable>
      da:	85 ed       	ldi	r24, 0xD5	; 213
      dc:	96 e0       	ldi	r25, 0x06	; 6
      de:	01 97       	sbiw	r24, 0x01	; 1
      e0:	f1 f7       	brne	.-4      	; 0xde <Lcd_Init+0x2a>
      e2:	00 c0       	rjmp	.+0      	; 0xe4 <Lcd_Init+0x30>
      e4:	00 00       	nop
      e6:	18 ba       	out	0x18, r1	; 24
      e8:	88 e3       	ldi	r24, 0x38	; 56
      ea:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
      ee:	0e 94 49 00 	call	0x92	; 0x92 <send_enable>
      f2:	8f e2       	ldi	r24, 0x2F	; 47
      f4:	95 e7       	ldi	r25, 0x75	; 117
      f6:	01 97       	sbiw	r24, 0x01	; 1
      f8:	f1 f7       	brne	.-4      	; 0xf6 <Lcd_Init+0x42>
      fa:	00 c0       	rjmp	.+0      	; 0xfc <Lcd_Init+0x48>
      fc:	00 00       	nop
      fe:	18 ba       	out	0x18, r1	; 24
     100:	88 e3       	ldi	r24, 0x38	; 56
     102:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
     106:	0e 94 49 00 	call	0x92	; 0x92 <send_enable>
     10a:	81 e0       	ldi	r24, 0x01	; 1
     10c:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
     110:	83 ec       	ldi	r24, 0xC3	; 195
     112:	99 e0       	ldi	r25, 0x09	; 9
     114:	01 97       	sbiw	r24, 0x01	; 1
     116:	f1 f7       	brne	.-4      	; 0x114 <Lcd_Init+0x60>
     118:	00 c0       	rjmp	.+0      	; 0x11a <Lcd_Init+0x66>
     11a:	00 00       	nop
     11c:	82 e0       	ldi	r24, 0x02	; 2
     11e:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
     122:	83 ec       	ldi	r24, 0xC3	; 195
     124:	99 e0       	ldi	r25, 0x09	; 9
     126:	01 97       	sbiw	r24, 0x01	; 1
     128:	f1 f7       	brne	.-4      	; 0x126 <Lcd_Init+0x72>
     12a:	00 c0       	rjmp	.+0      	; 0x12c <Lcd_Init+0x78>
     12c:	00 00       	nop
     12e:	86 e0       	ldi	r24, 0x06	; 6
     130:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
     134:	83 ec       	ldi	r24, 0xC3	; 195
     136:	99 e0       	ldi	r25, 0x09	; 9
     138:	01 97       	sbiw	r24, 0x01	; 1
     13a:	f1 f7       	brne	.-4      	; 0x138 <Lcd_Init+0x84>
     13c:	00 c0       	rjmp	.+0      	; 0x13e <Lcd_Init+0x8a>
     13e:	00 00       	nop
     140:	8d e0       	ldi	r24, 0x0D	; 13
     142:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
     146:	83 ec       	ldi	r24, 0xC3	; 195
     148:	99 e0       	ldi	r25, 0x09	; 9
     14a:	01 97       	sbiw	r24, 0x01	; 1
     14c:	f1 f7       	brne	.-4      	; 0x14a <Lcd_Init+0x96>
     14e:	00 c0       	rjmp	.+0      	; 0x150 <Lcd_Init+0x9c>
     150:	00 00       	nop
     152:	80 e1       	ldi	r24, 0x10	; 16
     154:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
     158:	83 ec       	ldi	r24, 0xC3	; 195
     15a:	99 e0       	ldi	r25, 0x09	; 9
     15c:	01 97       	sbiw	r24, 0x01	; 1
     15e:	f1 f7       	brne	.-4      	; 0x15c <Lcd_Init+0xa8>
     160:	00 c0       	rjmp	.+0      	; 0x162 <Lcd_Init+0xae>
     162:	00 00       	nop
     164:	86 e5       	ldi	r24, 0x56	; 86
     166:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
     16a:	83 ec       	ldi	r24, 0xC3	; 195
     16c:	99 e0       	ldi	r25, 0x09	; 9
     16e:	01 97       	sbiw	r24, 0x01	; 1
     170:	f1 f7       	brne	.-4      	; 0x16e <Lcd_Init+0xba>
     172:	00 c0       	rjmp	.+0      	; 0x174 <Lcd_Init+0xc0>
     174:	00 00       	nop
     176:	80 e8       	ldi	r24, 0x80	; 128
     178:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
     17c:	83 ec       	ldi	r24, 0xC3	; 195
     17e:	99 e0       	ldi	r25, 0x09	; 9
     180:	01 97       	sbiw	r24, 0x01	; 1
     182:	f1 f7       	brne	.-4      	; 0x180 <Lcd_Init+0xcc>
     184:	00 c0       	rjmp	.+0      	; 0x186 <Lcd_Init+0xd2>
     186:	00 00       	nop
     188:	08 95       	ret

0000018a <Lcd_Out>:

// to show strings
void Lcd_Out(char row, char column, char *text){
     18a:	cf 93       	push	r28
     18c:	df 93       	push	r29
     18e:	ea 01       	movw	r28, r20
	row-- ;
	column--;
	send_command((0x80 + 0x40 * row)+ column );
     190:	90 e4       	ldi	r25, 0x40	; 64
     192:	89 9f       	mul	r24, r25
     194:	60 0d       	add	r22, r0
     196:	11 24       	eor	r1, r1
     198:	86 2f       	mov	r24, r22
     19a:	81 5c       	subi	r24, 0xC1	; 193
     19c:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1a0:	89 ef       	ldi	r24, 0xF9	; 249
     1a2:	90 e0       	ldi	r25, 0x00	; 0
     1a4:	01 97       	sbiw	r24, 0x01	; 1
     1a6:	f1 f7       	brne	.-4      	; 0x1a4 <Lcd_Out+0x1a>
     1a8:	00 c0       	rjmp	.+0      	; 0x1aa <Lcd_Out+0x20>
     1aa:	00 00       	nop
	_delay_ms(1);
	while(*text){
     1ac:	88 81       	ld	r24, Y
     1ae:	88 23       	and	r24, r24
     1b0:	61 f0       	breq	.+24     	; 0x1ca <Lcd_Out+0x40>
     1b2:	21 96       	adiw	r28, 0x01	; 1
		send_data(*text++);
     1b4:	0e 94 54 00 	call	0xa8	; 0xa8 <send_data>
     1b8:	83 ec       	ldi	r24, 0xC3	; 195
     1ba:	99 e0       	ldi	r25, 0x09	; 9
     1bc:	01 97       	sbiw	r24, 0x01	; 1
     1be:	f1 f7       	brne	.-4      	; 0x1bc <Lcd_Out+0x32>
     1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <Lcd_Out+0x38>
     1c2:	00 00       	nop
void Lcd_Out(char row, char column, char *text){
	row-- ;
	column--;
	send_command((0x80 + 0x40 * row)+ column );
	_delay_ms(1);
	while(*text){
     1c4:	89 91       	ld	r24, Y+
     1c6:	81 11       	cpse	r24, r1
     1c8:	f5 cf       	rjmp	.-22     	; 0x1b4 <Lcd_Out+0x2a>
		send_data(*text++);
		_delay_ms(10);
	}

}
     1ca:	df 91       	pop	r29
     1cc:	cf 91       	pop	r28
     1ce:	08 95       	ret

000001d0 <task1>:
}

void task1(void *p){
	
	while(1) {
		xSemaphoreTake(smphr_lcd ,portMAX_DELAY);
     1d0:	6f ef       	ldi	r22, 0xFF	; 255
     1d2:	7f ef       	ldi	r23, 0xFF	; 255
     1d4:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__data_end>
     1d8:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <__data_end+0x1>
     1dc:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <xQueueSemaphoreTake>
		send_command(_LCD_CLEAR);
     1e0:	81 e0       	ldi	r24, 0x01	; 1
     1e2:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
     1e6:	83 ec       	ldi	r24, 0xC3	; 195
     1e8:	99 e0       	ldi	r25, 0x09	; 9
     1ea:	01 97       	sbiw	r24, 0x01	; 1
     1ec:	f1 f7       	brne	.-4      	; 0x1ea <task1+0x1a>
     1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <task1+0x20>
     1f0:	00 00       	nop
		_delay_ms(10);
		Lcd_Out(1 , 1 , "lowest priority task");
     1f2:	40 e6       	ldi	r20, 0x60	; 96
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	61 e0       	ldi	r22, 0x01	; 1
     1f8:	81 e0       	ldi	r24, 0x01	; 1
     1fa:	0e 94 c5 00 	call	0x18a	; 0x18a <Lcd_Out>
     1fe:	9f e5       	ldi	r25, 0x5F	; 95
     200:	2a ee       	ldi	r18, 0xEA	; 234
     202:	80 e0       	ldi	r24, 0x00	; 0
     204:	91 50       	subi	r25, 0x01	; 1
     206:	20 40       	sbci	r18, 0x00	; 0
     208:	80 40       	sbci	r24, 0x00	; 0
     20a:	e1 f7       	brne	.-8      	; 0x204 <task1+0x34>
     20c:	00 c0       	rjmp	.+0      	; 0x20e <task1+0x3e>
     20e:	00 00       	nop
		_delay_ms(300);
		xSemaphoreGive(smphr_lcd);	
     210:	20 e0       	ldi	r18, 0x00	; 0
     212:	40 e0       	ldi	r20, 0x00	; 0
     214:	50 e0       	ldi	r21, 0x00	; 0
     216:	60 e0       	ldi	r22, 0x00	; 0
     218:	70 e0       	ldi	r23, 0x00	; 0
     21a:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__data_end>
     21e:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <__data_end+0x1>
     222:	0e 94 bf 04 	call	0x97e	; 0x97e <xQueueGenericSend>
     226:	d4 cf       	rjmp	.-88     	; 0x1d0 <task1>

00000228 <task3>:
}

void task3(void *p){
	
	while(1) {
		vTaskDelay(10);
     228:	8a e0       	ldi	r24, 0x0A	; 10
     22a:	90 e0       	ldi	r25, 0x00	; 0
     22c:	0e 94 c5 09 	call	0x138a	; 0x138a <vTaskDelay>
		xSemaphoreTake(smphr_lcd ,portMAX_DELAY);
     230:	6f ef       	ldi	r22, 0xFF	; 255
     232:	7f ef       	ldi	r23, 0xFF	; 255
     234:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__data_end>
     238:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <__data_end+0x1>
     23c:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <xQueueSemaphoreTake>
		send_command(_LCD_CLEAR);
     240:	81 e0       	ldi	r24, 0x01	; 1
     242:	0e 94 4e 00 	call	0x9c	; 0x9c <send_command>
     246:	83 ec       	ldi	r24, 0xC3	; 195
     248:	99 e0       	ldi	r25, 0x09	; 9
     24a:	01 97       	sbiw	r24, 0x01	; 1
     24c:	f1 f7       	brne	.-4      	; 0x24a <task3+0x22>
     24e:	00 c0       	rjmp	.+0      	; 0x250 <task3+0x28>
     250:	00 00       	nop
		_delay_ms(10);
		Lcd_Out(1 , 1 , "highest priority task");
     252:	45 e7       	ldi	r20, 0x75	; 117
     254:	50 e0       	ldi	r21, 0x00	; 0
     256:	61 e0       	ldi	r22, 0x01	; 1
     258:	81 e0       	ldi	r24, 0x01	; 1
     25a:	0e 94 c5 00 	call	0x18a	; 0x18a <Lcd_Out>
     25e:	9f e3       	ldi	r25, 0x3F	; 63
     260:	2d e0       	ldi	r18, 0x0D	; 13
     262:	83 e0       	ldi	r24, 0x03	; 3
     264:	91 50       	subi	r25, 0x01	; 1
     266:	20 40       	sbci	r18, 0x00	; 0
     268:	80 40       	sbci	r24, 0x00	; 0
     26a:	e1 f7       	brne	.-8      	; 0x264 <task3+0x3c>
     26c:	00 c0       	rjmp	.+0      	; 0x26e <task3+0x46>
     26e:	00 00       	nop
		_delay_ms(1000);
		xSemaphoreGive(smphr_lcd);	
     270:	20 e0       	ldi	r18, 0x00	; 0
     272:	40 e0       	ldi	r20, 0x00	; 0
     274:	50 e0       	ldi	r21, 0x00	; 0
     276:	60 e0       	ldi	r22, 0x00	; 0
     278:	70 e0       	ldi	r23, 0x00	; 0
     27a:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__data_end>
     27e:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <__data_end+0x1>
     282:	0e 94 bf 04 	call	0x97e	; 0x97e <xQueueGenericSend>
     286:	d0 cf       	rjmp	.-96     	; 0x228 <task3>

00000288 <task2>:
	}
	
}

void task2(void *p){
	DDRD |= (1 << 0);
     288:	88 9a       	sbi	0x11, 0	; 17
	while(1) {
		vTaskDelay(200);
     28a:	88 ec       	ldi	r24, 0xC8	; 200
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	0e 94 c5 09 	call	0x138a	; 0x138a <vTaskDelay>
		PORTD |= (1 << 0);
     292:	90 9a       	sbi	0x12, 0	; 18
		/*_delay_ms(1000);
		PORTD &= ~(1 << 0);
		_delay_ms(1000);*/
		vTaskDelete(NULL);	
     294:	80 e0       	ldi	r24, 0x00	; 0
     296:	90 e0       	ldi	r25, 0x00	; 0
     298:	0e 94 fe 07 	call	0xffc	; 0xffc <vTaskDelete>
     29c:	f6 cf       	rjmp	.-20     	; 0x28a <task2+0x2>

0000029e <main>:
/*                 handlers                       */
SemaphoreHandle_t smphr_lcd =NULL ;

int main(void)
{
	Lcd_Init();
     29e:	0e 94 5a 00 	call	0xb4	; 0xb4 <Lcd_Init>
    xTaskCreate(task1 , NULL , 85 , NULL , 1 , NULL);
     2a2:	e1 2c       	mov	r14, r1
     2a4:	f1 2c       	mov	r15, r1
     2a6:	01 e0       	ldi	r16, 0x01	; 1
     2a8:	20 e0       	ldi	r18, 0x00	; 0
     2aa:	30 e0       	ldi	r19, 0x00	; 0
     2ac:	45 e5       	ldi	r20, 0x55	; 85
     2ae:	50 e0       	ldi	r21, 0x00	; 0
     2b0:	60 e0       	ldi	r22, 0x00	; 0
     2b2:	70 e0       	ldi	r23, 0x00	; 0
     2b4:	88 ee       	ldi	r24, 0xE8	; 232
     2b6:	90 e0       	ldi	r25, 0x00	; 0
     2b8:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <xTaskCreate>
	xTaskCreate(task2 , NULL , 85 , NULL , 2 , NULL);
     2bc:	02 e0       	ldi	r16, 0x02	; 2
     2be:	20 e0       	ldi	r18, 0x00	; 0
     2c0:	30 e0       	ldi	r19, 0x00	; 0
     2c2:	45 e5       	ldi	r20, 0x55	; 85
     2c4:	50 e0       	ldi	r21, 0x00	; 0
     2c6:	60 e0       	ldi	r22, 0x00	; 0
     2c8:	70 e0       	ldi	r23, 0x00	; 0
     2ca:	84 e4       	ldi	r24, 0x44	; 68
     2cc:	91 e0       	ldi	r25, 0x01	; 1
     2ce:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <xTaskCreate>
	xTaskCreate(task3 , NULL , 85 , NULL , 3 , NULL);
     2d2:	03 e0       	ldi	r16, 0x03	; 3
     2d4:	20 e0       	ldi	r18, 0x00	; 0
     2d6:	30 e0       	ldi	r19, 0x00	; 0
     2d8:	45 e5       	ldi	r20, 0x55	; 85
     2da:	50 e0       	ldi	r21, 0x00	; 0
     2dc:	60 e0       	ldi	r22, 0x00	; 0
     2de:	70 e0       	ldi	r23, 0x00	; 0
     2e0:	84 e1       	ldi	r24, 0x14	; 20
     2e2:	91 e0       	ldi	r25, 0x01	; 1
     2e4:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <xTaskCreate>
	smphr_lcd = xSemaphoreCreateMutex();
     2e8:	81 e0       	ldi	r24, 0x01	; 1
     2ea:	0e 94 60 05 	call	0xac0	; 0xac0 <xQueueCreateMutex>
     2ee:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <__data_end+0x1>
     2f2:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__data_end>
	xSemaphoreGive(smphr_lcd);
     2f6:	20 e0       	ldi	r18, 0x00	; 0
     2f8:	40 e0       	ldi	r20, 0x00	; 0
     2fa:	50 e0       	ldi	r21, 0x00	; 0
     2fc:	60 e0       	ldi	r22, 0x00	; 0
     2fe:	70 e0       	ldi	r23, 0x00	; 0
     300:	0e 94 bf 04 	call	0x97e	; 0x97e <xQueueGenericSend>
	
	vTaskStartScheduler();
     304:	0e 94 53 08 	call	0x10a6	; 0x10a6 <vTaskStartScheduler>
     308:	ff cf       	rjmp	.-2      	; 0x308 <main+0x6a>

0000030a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     30a:	cf 93       	push	r28
     30c:	df 93       	push	r29
     30e:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     310:	0e 94 7d 08 	call	0x10fa	; 0x10fa <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     314:	80 91 92 00 	lds	r24, 0x0092	; 0x800092 <pucAlignedHeap.2101>
     318:	90 91 93 00 	lds	r25, 0x0093	; 0x800093 <pucAlignedHeap.2101+0x1>
     31c:	89 2b       	or	r24, r25
     31e:	31 f4       	brne	.+12     	; 0x32c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     320:	87 e9       	ldi	r24, 0x97	; 151
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	90 93 93 00 	sts	0x0093, r25	; 0x800093 <pucAlignedHeap.2101+0x1>
     328:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <pucAlignedHeap.2101>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     32c:	20 91 94 00 	lds	r18, 0x0094	; 0x800094 <xNextFreeByte>
     330:	30 91 95 00 	lds	r19, 0x0095	; 0x800095 <xNextFreeByte+0x1>
     334:	c9 01       	movw	r24, r18
     336:	8c 0f       	add	r24, r28
     338:	9d 1f       	adc	r25, r29
     33a:	87 35       	cpi	r24, 0x57	; 87
     33c:	42 e0       	ldi	r20, 0x02	; 2
     33e:	94 07       	cpc	r25, r20
     340:	70 f4       	brcc	.+28     	; 0x35e <pvPortMalloc+0x54>
     342:	28 17       	cp	r18, r24
     344:	39 07       	cpc	r19, r25
     346:	70 f4       	brcc	.+28     	; 0x364 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     348:	c0 91 92 00 	lds	r28, 0x0092	; 0x800092 <pucAlignedHeap.2101>
     34c:	d0 91 93 00 	lds	r29, 0x0093	; 0x800093 <pucAlignedHeap.2101+0x1>
     350:	c2 0f       	add	r28, r18
     352:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     354:	90 93 95 00 	sts	0x0095, r25	; 0x800095 <xNextFreeByte+0x1>
     358:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <xNextFreeByte>
     35c:	05 c0       	rjmp	.+10     	; 0x368 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     35e:	c0 e0       	ldi	r28, 0x00	; 0
     360:	d0 e0       	ldi	r29, 0x00	; 0
     362:	02 c0       	rjmp	.+4      	; 0x368 <pvPortMalloc+0x5e>
     364:	c0 e0       	ldi	r28, 0x00	; 0
     366:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     368:	0e 94 42 09 	call	0x1284	; 0x1284 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     36c:	ce 01       	movw	r24, r28
     36e:	df 91       	pop	r29
     370:	cf 91       	pop	r28
     372:	08 95       	ret

00000374 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     374:	08 95       	ret

00000376 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     376:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     378:	03 96       	adiw	r24, 0x03	; 3
     37a:	92 83       	std	Z+2, r25	; 0x02
     37c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     37e:	2f ef       	ldi	r18, 0xFF	; 255
     380:	3f ef       	ldi	r19, 0xFF	; 255
     382:	34 83       	std	Z+4, r19	; 0x04
     384:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     386:	96 83       	std	Z+6, r25	; 0x06
     388:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     38a:	90 87       	std	Z+8, r25	; 0x08
     38c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     38e:	10 82       	st	Z, r1
     390:	08 95       	ret

00000392 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     392:	fc 01       	movw	r30, r24
     394:	11 86       	std	Z+9, r1	; 0x09
     396:	10 86       	std	Z+8, r1	; 0x08
     398:	08 95       	ret

0000039a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     39a:	cf 93       	push	r28
     39c:	df 93       	push	r29
     39e:	9c 01       	movw	r18, r24
     3a0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     3a2:	dc 01       	movw	r26, r24
     3a4:	11 96       	adiw	r26, 0x01	; 1
     3a6:	cd 91       	ld	r28, X+
     3a8:	dc 91       	ld	r29, X
     3aa:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     3ac:	d3 83       	std	Z+3, r29	; 0x03
     3ae:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     3b0:	8c 81       	ldd	r24, Y+4	; 0x04
     3b2:	9d 81       	ldd	r25, Y+5	; 0x05
     3b4:	95 83       	std	Z+5, r25	; 0x05
     3b6:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     3b8:	8c 81       	ldd	r24, Y+4	; 0x04
     3ba:	9d 81       	ldd	r25, Y+5	; 0x05
     3bc:	dc 01       	movw	r26, r24
     3be:	13 96       	adiw	r26, 0x03	; 3
     3c0:	7c 93       	st	X, r23
     3c2:	6e 93       	st	-X, r22
     3c4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     3c6:	7d 83       	std	Y+5, r23	; 0x05
     3c8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     3ca:	31 87       	std	Z+9, r19	; 0x09
     3cc:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     3ce:	f9 01       	movw	r30, r18
     3d0:	80 81       	ld	r24, Z
     3d2:	8f 5f       	subi	r24, 0xFF	; 255
     3d4:	80 83       	st	Z, r24
}
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	08 95       	ret

000003dc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3dc:	cf 93       	push	r28
     3de:	df 93       	push	r29
     3e0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     3e2:	48 81       	ld	r20, Y
     3e4:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     3e6:	4f 3f       	cpi	r20, 0xFF	; 255
     3e8:	2f ef       	ldi	r18, 0xFF	; 255
     3ea:	52 07       	cpc	r21, r18
     3ec:	21 f4       	brne	.+8      	; 0x3f6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     3ee:	fc 01       	movw	r30, r24
     3f0:	a7 81       	ldd	r26, Z+7	; 0x07
     3f2:	b0 85       	ldd	r27, Z+8	; 0x08
     3f4:	0d c0       	rjmp	.+26     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     3f6:	dc 01       	movw	r26, r24
     3f8:	13 96       	adiw	r26, 0x03	; 3
     3fa:	01 c0       	rjmp	.+2      	; 0x3fe <vListInsert+0x22>
     3fc:	df 01       	movw	r26, r30
     3fe:	12 96       	adiw	r26, 0x02	; 2
     400:	ed 91       	ld	r30, X+
     402:	fc 91       	ld	r31, X
     404:	13 97       	sbiw	r26, 0x03	; 3
     406:	20 81       	ld	r18, Z
     408:	31 81       	ldd	r19, Z+1	; 0x01
     40a:	42 17       	cp	r20, r18
     40c:	53 07       	cpc	r21, r19
     40e:	b0 f7       	brcc	.-20     	; 0x3fc <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     410:	12 96       	adiw	r26, 0x02	; 2
     412:	ed 91       	ld	r30, X+
     414:	fc 91       	ld	r31, X
     416:	13 97       	sbiw	r26, 0x03	; 3
     418:	fb 83       	std	Y+3, r31	; 0x03
     41a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     41c:	d5 83       	std	Z+5, r29	; 0x05
     41e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     420:	bd 83       	std	Y+5, r27	; 0x05
     422:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     424:	13 96       	adiw	r26, 0x03	; 3
     426:	dc 93       	st	X, r29
     428:	ce 93       	st	-X, r28
     42a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     42c:	99 87       	std	Y+9, r25	; 0x09
     42e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     430:	fc 01       	movw	r30, r24
     432:	20 81       	ld	r18, Z
     434:	2f 5f       	subi	r18, 0xFF	; 255
     436:	20 83       	st	Z, r18
}
     438:	df 91       	pop	r29
     43a:	cf 91       	pop	r28
     43c:	08 95       	ret

0000043e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     43e:	cf 93       	push	r28
     440:	df 93       	push	r29
     442:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     444:	a0 85       	ldd	r26, Z+8	; 0x08
     446:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     448:	c2 81       	ldd	r28, Z+2	; 0x02
     44a:	d3 81       	ldd	r29, Z+3	; 0x03
     44c:	84 81       	ldd	r24, Z+4	; 0x04
     44e:	95 81       	ldd	r25, Z+5	; 0x05
     450:	9d 83       	std	Y+5, r25	; 0x05
     452:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     454:	c4 81       	ldd	r28, Z+4	; 0x04
     456:	d5 81       	ldd	r29, Z+5	; 0x05
     458:	82 81       	ldd	r24, Z+2	; 0x02
     45a:	93 81       	ldd	r25, Z+3	; 0x03
     45c:	9b 83       	std	Y+3, r25	; 0x03
     45e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     460:	11 96       	adiw	r26, 0x01	; 1
     462:	8d 91       	ld	r24, X+
     464:	9c 91       	ld	r25, X
     466:	12 97       	sbiw	r26, 0x02	; 2
     468:	e8 17       	cp	r30, r24
     46a:	f9 07       	cpc	r31, r25
     46c:	31 f4       	brne	.+12     	; 0x47a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     46e:	84 81       	ldd	r24, Z+4	; 0x04
     470:	95 81       	ldd	r25, Z+5	; 0x05
     472:	12 96       	adiw	r26, 0x02	; 2
     474:	9c 93       	st	X, r25
     476:	8e 93       	st	-X, r24
     478:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     47a:	11 86       	std	Z+9, r1	; 0x09
     47c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     47e:	8c 91       	ld	r24, X
     480:	81 50       	subi	r24, 0x01	; 1
     482:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     484:	8c 91       	ld	r24, X
}
     486:	df 91       	pop	r29
     488:	cf 91       	pop	r28
     48a:	08 95       	ret

0000048c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     48c:	31 e1       	ldi	r19, 0x11	; 17
     48e:	fc 01       	movw	r30, r24
     490:	30 83       	st	Z, r19
     492:	31 97       	sbiw	r30, 0x01	; 1
     494:	22 e2       	ldi	r18, 0x22	; 34
     496:	20 83       	st	Z, r18
     498:	31 97       	sbiw	r30, 0x01	; 1
     49a:	a3 e3       	ldi	r26, 0x33	; 51
     49c:	a0 83       	st	Z, r26
     49e:	31 97       	sbiw	r30, 0x01	; 1
     4a0:	60 83       	st	Z, r22
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	70 83       	st	Z, r23
     4a6:	31 97       	sbiw	r30, 0x01	; 1
     4a8:	10 82       	st	Z, r1
     4aa:	31 97       	sbiw	r30, 0x01	; 1
     4ac:	60 e8       	ldi	r22, 0x80	; 128
     4ae:	60 83       	st	Z, r22
     4b0:	31 97       	sbiw	r30, 0x01	; 1
     4b2:	10 82       	st	Z, r1
     4b4:	31 97       	sbiw	r30, 0x01	; 1
     4b6:	62 e0       	ldi	r22, 0x02	; 2
     4b8:	60 83       	st	Z, r22
     4ba:	31 97       	sbiw	r30, 0x01	; 1
     4bc:	63 e0       	ldi	r22, 0x03	; 3
     4be:	60 83       	st	Z, r22
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	64 e0       	ldi	r22, 0x04	; 4
     4c4:	60 83       	st	Z, r22
     4c6:	31 97       	sbiw	r30, 0x01	; 1
     4c8:	65 e0       	ldi	r22, 0x05	; 5
     4ca:	60 83       	st	Z, r22
     4cc:	31 97       	sbiw	r30, 0x01	; 1
     4ce:	66 e0       	ldi	r22, 0x06	; 6
     4d0:	60 83       	st	Z, r22
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	67 e0       	ldi	r22, 0x07	; 7
     4d6:	60 83       	st	Z, r22
     4d8:	31 97       	sbiw	r30, 0x01	; 1
     4da:	68 e0       	ldi	r22, 0x08	; 8
     4dc:	60 83       	st	Z, r22
     4de:	31 97       	sbiw	r30, 0x01	; 1
     4e0:	69 e0       	ldi	r22, 0x09	; 9
     4e2:	60 83       	st	Z, r22
     4e4:	31 97       	sbiw	r30, 0x01	; 1
     4e6:	60 e1       	ldi	r22, 0x10	; 16
     4e8:	60 83       	st	Z, r22
     4ea:	31 97       	sbiw	r30, 0x01	; 1
     4ec:	30 83       	st	Z, r19
     4ee:	31 97       	sbiw	r30, 0x01	; 1
     4f0:	32 e1       	ldi	r19, 0x12	; 18
     4f2:	30 83       	st	Z, r19
     4f4:	31 97       	sbiw	r30, 0x01	; 1
     4f6:	33 e1       	ldi	r19, 0x13	; 19
     4f8:	30 83       	st	Z, r19
     4fa:	31 97       	sbiw	r30, 0x01	; 1
     4fc:	34 e1       	ldi	r19, 0x14	; 20
     4fe:	30 83       	st	Z, r19
     500:	31 97       	sbiw	r30, 0x01	; 1
     502:	35 e1       	ldi	r19, 0x15	; 21
     504:	30 83       	st	Z, r19
     506:	31 97       	sbiw	r30, 0x01	; 1
     508:	36 e1       	ldi	r19, 0x16	; 22
     50a:	30 83       	st	Z, r19
     50c:	31 97       	sbiw	r30, 0x01	; 1
     50e:	37 e1       	ldi	r19, 0x17	; 23
     510:	30 83       	st	Z, r19
     512:	31 97       	sbiw	r30, 0x01	; 1
     514:	38 e1       	ldi	r19, 0x18	; 24
     516:	30 83       	st	Z, r19
     518:	31 97       	sbiw	r30, 0x01	; 1
     51a:	39 e1       	ldi	r19, 0x19	; 25
     51c:	30 83       	st	Z, r19
     51e:	31 97       	sbiw	r30, 0x01	; 1
     520:	30 e2       	ldi	r19, 0x20	; 32
     522:	30 83       	st	Z, r19
     524:	31 97       	sbiw	r30, 0x01	; 1
     526:	31 e2       	ldi	r19, 0x21	; 33
     528:	30 83       	st	Z, r19
     52a:	31 97       	sbiw	r30, 0x01	; 1
     52c:	20 83       	st	Z, r18
     52e:	31 97       	sbiw	r30, 0x01	; 1
     530:	23 e2       	ldi	r18, 0x23	; 35
     532:	20 83       	st	Z, r18
     534:	31 97       	sbiw	r30, 0x01	; 1
     536:	40 83       	st	Z, r20
     538:	31 97       	sbiw	r30, 0x01	; 1
     53a:	50 83       	st	Z, r21
     53c:	31 97       	sbiw	r30, 0x01	; 1
     53e:	26 e2       	ldi	r18, 0x26	; 38
     540:	20 83       	st	Z, r18
     542:	31 97       	sbiw	r30, 0x01	; 1
     544:	27 e2       	ldi	r18, 0x27	; 39
     546:	20 83       	st	Z, r18
     548:	31 97       	sbiw	r30, 0x01	; 1
     54a:	28 e2       	ldi	r18, 0x28	; 40
     54c:	20 83       	st	Z, r18
     54e:	31 97       	sbiw	r30, 0x01	; 1
     550:	29 e2       	ldi	r18, 0x29	; 41
     552:	20 83       	st	Z, r18
     554:	31 97       	sbiw	r30, 0x01	; 1
     556:	20 e3       	ldi	r18, 0x30	; 48
     558:	20 83       	st	Z, r18
     55a:	31 97       	sbiw	r30, 0x01	; 1
     55c:	21 e3       	ldi	r18, 0x31	; 49
     55e:	20 83       	st	Z, r18
     560:	86 97       	sbiw	r24, 0x26	; 38
     562:	08 95       	ret

00000564 <xPortStartScheduler>:
     564:	1b bc       	out	0x2b, r1	; 43
     566:	8e e0       	ldi	r24, 0x0E	; 14
     568:	8a bd       	out	0x2a, r24	; 42
     56a:	8b e0       	ldi	r24, 0x0B	; 11
     56c:	8e bd       	out	0x2e, r24	; 46
     56e:	89 b7       	in	r24, 0x39	; 57
     570:	80 61       	ori	r24, 0x10	; 16
     572:	89 bf       	out	0x39, r24	; 57
     574:	a0 91 53 03 	lds	r26, 0x0353	; 0x800353 <pxCurrentTCB>
     578:	b0 91 54 03 	lds	r27, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     57c:	cd 91       	ld	r28, X+
     57e:	cd bf       	out	0x3d, r28	; 61
     580:	dd 91       	ld	r29, X+
     582:	de bf       	out	0x3e, r29	; 62
     584:	ff 91       	pop	r31
     586:	ef 91       	pop	r30
     588:	df 91       	pop	r29
     58a:	cf 91       	pop	r28
     58c:	bf 91       	pop	r27
     58e:	af 91       	pop	r26
     590:	9f 91       	pop	r25
     592:	8f 91       	pop	r24
     594:	7f 91       	pop	r23
     596:	6f 91       	pop	r22
     598:	5f 91       	pop	r21
     59a:	4f 91       	pop	r20
     59c:	3f 91       	pop	r19
     59e:	2f 91       	pop	r18
     5a0:	1f 91       	pop	r17
     5a2:	0f 91       	pop	r16
     5a4:	ff 90       	pop	r15
     5a6:	ef 90       	pop	r14
     5a8:	df 90       	pop	r13
     5aa:	cf 90       	pop	r12
     5ac:	bf 90       	pop	r11
     5ae:	af 90       	pop	r10
     5b0:	9f 90       	pop	r9
     5b2:	8f 90       	pop	r8
     5b4:	7f 90       	pop	r7
     5b6:	6f 90       	pop	r6
     5b8:	5f 90       	pop	r5
     5ba:	4f 90       	pop	r4
     5bc:	3f 90       	pop	r3
     5be:	2f 90       	pop	r2
     5c0:	1f 90       	pop	r1
     5c2:	0f 90       	pop	r0
     5c4:	0f be       	out	0x3f, r0	; 63
     5c6:	0f 90       	pop	r0
     5c8:	08 95       	ret
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	08 95       	ret

000005ce <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5ce:	0f 92       	push	r0
     5d0:	0f b6       	in	r0, 0x3f	; 63
     5d2:	f8 94       	cli
     5d4:	0f 92       	push	r0
     5d6:	1f 92       	push	r1
     5d8:	11 24       	eor	r1, r1
     5da:	2f 92       	push	r2
     5dc:	3f 92       	push	r3
     5de:	4f 92       	push	r4
     5e0:	5f 92       	push	r5
     5e2:	6f 92       	push	r6
     5e4:	7f 92       	push	r7
     5e6:	8f 92       	push	r8
     5e8:	9f 92       	push	r9
     5ea:	af 92       	push	r10
     5ec:	bf 92       	push	r11
     5ee:	cf 92       	push	r12
     5f0:	df 92       	push	r13
     5f2:	ef 92       	push	r14
     5f4:	ff 92       	push	r15
     5f6:	0f 93       	push	r16
     5f8:	1f 93       	push	r17
     5fa:	2f 93       	push	r18
     5fc:	3f 93       	push	r19
     5fe:	4f 93       	push	r20
     600:	5f 93       	push	r21
     602:	6f 93       	push	r22
     604:	7f 93       	push	r23
     606:	8f 93       	push	r24
     608:	9f 93       	push	r25
     60a:	af 93       	push	r26
     60c:	bf 93       	push	r27
     60e:	cf 93       	push	r28
     610:	df 93       	push	r29
     612:	ef 93       	push	r30
     614:	ff 93       	push	r31
     616:	a0 91 53 03 	lds	r26, 0x0353	; 0x800353 <pxCurrentTCB>
     61a:	b0 91 54 03 	lds	r27, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     61e:	0d b6       	in	r0, 0x3d	; 61
     620:	0d 92       	st	X+, r0
     622:	0e b6       	in	r0, 0x3e	; 62
     624:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     626:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     62a:	a0 91 53 03 	lds	r26, 0x0353	; 0x800353 <pxCurrentTCB>
     62e:	b0 91 54 03 	lds	r27, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     632:	cd 91       	ld	r28, X+
     634:	cd bf       	out	0x3d, r28	; 61
     636:	dd 91       	ld	r29, X+
     638:	de bf       	out	0x3e, r29	; 62
     63a:	ff 91       	pop	r31
     63c:	ef 91       	pop	r30
     63e:	df 91       	pop	r29
     640:	cf 91       	pop	r28
     642:	bf 91       	pop	r27
     644:	af 91       	pop	r26
     646:	9f 91       	pop	r25
     648:	8f 91       	pop	r24
     64a:	7f 91       	pop	r23
     64c:	6f 91       	pop	r22
     64e:	5f 91       	pop	r21
     650:	4f 91       	pop	r20
     652:	3f 91       	pop	r19
     654:	2f 91       	pop	r18
     656:	1f 91       	pop	r17
     658:	0f 91       	pop	r16
     65a:	ff 90       	pop	r15
     65c:	ef 90       	pop	r14
     65e:	df 90       	pop	r13
     660:	cf 90       	pop	r12
     662:	bf 90       	pop	r11
     664:	af 90       	pop	r10
     666:	9f 90       	pop	r9
     668:	8f 90       	pop	r8
     66a:	7f 90       	pop	r7
     66c:	6f 90       	pop	r6
     66e:	5f 90       	pop	r5
     670:	4f 90       	pop	r4
     672:	3f 90       	pop	r3
     674:	2f 90       	pop	r2
     676:	1f 90       	pop	r1
     678:	0f 90       	pop	r0
     67a:	0f be       	out	0x3f, r0	; 63
     67c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67e:	08 95       	ret

00000680 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     680:	0f 92       	push	r0
     682:	0f b6       	in	r0, 0x3f	; 63
     684:	f8 94       	cli
     686:	0f 92       	push	r0
     688:	1f 92       	push	r1
     68a:	11 24       	eor	r1, r1
     68c:	2f 92       	push	r2
     68e:	3f 92       	push	r3
     690:	4f 92       	push	r4
     692:	5f 92       	push	r5
     694:	6f 92       	push	r6
     696:	7f 92       	push	r7
     698:	8f 92       	push	r8
     69a:	9f 92       	push	r9
     69c:	af 92       	push	r10
     69e:	bf 92       	push	r11
     6a0:	cf 92       	push	r12
     6a2:	df 92       	push	r13
     6a4:	ef 92       	push	r14
     6a6:	ff 92       	push	r15
     6a8:	0f 93       	push	r16
     6aa:	1f 93       	push	r17
     6ac:	2f 93       	push	r18
     6ae:	3f 93       	push	r19
     6b0:	4f 93       	push	r20
     6b2:	5f 93       	push	r21
     6b4:	6f 93       	push	r22
     6b6:	7f 93       	push	r23
     6b8:	8f 93       	push	r24
     6ba:	9f 93       	push	r25
     6bc:	af 93       	push	r26
     6be:	bf 93       	push	r27
     6c0:	cf 93       	push	r28
     6c2:	df 93       	push	r29
     6c4:	ef 93       	push	r30
     6c6:	ff 93       	push	r31
     6c8:	a0 91 53 03 	lds	r26, 0x0353	; 0x800353 <pxCurrentTCB>
     6cc:	b0 91 54 03 	lds	r27, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     6d0:	0d b6       	in	r0, 0x3d	; 61
     6d2:	0d 92       	st	X+, r0
     6d4:	0e b6       	in	r0, 0x3e	; 62
     6d6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     6d8:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskIncrementTick>
     6dc:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     6de:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     6e2:	a0 91 53 03 	lds	r26, 0x0353	; 0x800353 <pxCurrentTCB>
     6e6:	b0 91 54 03 	lds	r27, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     6ea:	cd 91       	ld	r28, X+
     6ec:	cd bf       	out	0x3d, r28	; 61
     6ee:	dd 91       	ld	r29, X+
     6f0:	de bf       	out	0x3e, r29	; 62
     6f2:	ff 91       	pop	r31
     6f4:	ef 91       	pop	r30
     6f6:	df 91       	pop	r29
     6f8:	cf 91       	pop	r28
     6fa:	bf 91       	pop	r27
     6fc:	af 91       	pop	r26
     6fe:	9f 91       	pop	r25
     700:	8f 91       	pop	r24
     702:	7f 91       	pop	r23
     704:	6f 91       	pop	r22
     706:	5f 91       	pop	r21
     708:	4f 91       	pop	r20
     70a:	3f 91       	pop	r19
     70c:	2f 91       	pop	r18
     70e:	1f 91       	pop	r17
     710:	0f 91       	pop	r16
     712:	ff 90       	pop	r15
     714:	ef 90       	pop	r14
     716:	df 90       	pop	r13
     718:	cf 90       	pop	r12
     71a:	bf 90       	pop	r11
     71c:	af 90       	pop	r10
     71e:	9f 90       	pop	r9
     720:	8f 90       	pop	r8
     722:	7f 90       	pop	r7
     724:	6f 90       	pop	r6
     726:	5f 90       	pop	r5
     728:	4f 90       	pop	r4
     72a:	3f 90       	pop	r3
     72c:	2f 90       	pop	r2
     72e:	1f 90       	pop	r1
     730:	0f 90       	pop	r0
     732:	0f be       	out	0x3f, r0	; 63
     734:	0f 90       	pop	r0

	asm volatile ( "ret" );
     736:	08 95       	ret

00000738 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     738:	0e 94 40 03 	call	0x680	; 0x680 <vPortYieldFromTick>
		asm volatile ( "reti" );
     73c:	18 95       	reti

0000073e <prvIsQueueEmpty>:
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
     73e:	0f b6       	in	r0, 0x3f	; 63
     740:	f8 94       	cli
     742:	0f 92       	push	r0
     744:	fc 01       	movw	r30, r24
     746:	92 8d       	ldd	r25, Z+26	; 0x1a
     748:	0f 90       	pop	r0
     74a:	0f be       	out	0x3f, r0	; 63
     74c:	81 e0       	ldi	r24, 0x01	; 1
     74e:	91 11       	cpse	r25, r1
     750:	80 e0       	ldi	r24, 0x00	; 0
     752:	08 95       	ret

00000754 <prvCopyDataToQueue>:
     754:	0f 93       	push	r16
     756:	1f 93       	push	r17
     758:	cf 93       	push	r28
     75a:	df 93       	push	r29
     75c:	ec 01       	movw	r28, r24
     75e:	04 2f       	mov	r16, r20
     760:	1a 8d       	ldd	r17, Y+26	; 0x1a
     762:	4c 8d       	ldd	r20, Y+28	; 0x1c
     764:	41 11       	cpse	r20, r1
     766:	0c c0       	rjmp	.+24     	; 0x780 <prvCopyDataToQueue+0x2c>
     768:	88 81       	ld	r24, Y
     76a:	99 81       	ldd	r25, Y+1	; 0x01
     76c:	89 2b       	or	r24, r25
     76e:	09 f0       	breq	.+2      	; 0x772 <prvCopyDataToQueue+0x1e>
     770:	42 c0       	rjmp	.+132    	; 0x7f6 <prvCopyDataToQueue+0xa2>
     772:	8c 81       	ldd	r24, Y+4	; 0x04
     774:	9d 81       	ldd	r25, Y+5	; 0x05
     776:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <xTaskPriorityDisinherit>
     77a:	1d 82       	std	Y+5, r1	; 0x05
     77c:	1c 82       	std	Y+4, r1	; 0x04
     77e:	42 c0       	rjmp	.+132    	; 0x804 <prvCopyDataToQueue+0xb0>
     780:	01 11       	cpse	r16, r1
     782:	17 c0       	rjmp	.+46     	; 0x7b2 <prvCopyDataToQueue+0x5e>
     784:	50 e0       	ldi	r21, 0x00	; 0
     786:	8a 81       	ldd	r24, Y+2	; 0x02
     788:	9b 81       	ldd	r25, Y+3	; 0x03
     78a:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <memcpy>
     78e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     790:	8a 81       	ldd	r24, Y+2	; 0x02
     792:	9b 81       	ldd	r25, Y+3	; 0x03
     794:	82 0f       	add	r24, r18
     796:	91 1d       	adc	r25, r1
     798:	9b 83       	std	Y+3, r25	; 0x03
     79a:	8a 83       	std	Y+2, r24	; 0x02
     79c:	2c 81       	ldd	r18, Y+4	; 0x04
     79e:	3d 81       	ldd	r19, Y+5	; 0x05
     7a0:	82 17       	cp	r24, r18
     7a2:	93 07       	cpc	r25, r19
     7a4:	50 f1       	brcs	.+84     	; 0x7fa <prvCopyDataToQueue+0xa6>
     7a6:	88 81       	ld	r24, Y
     7a8:	99 81       	ldd	r25, Y+1	; 0x01
     7aa:	9b 83       	std	Y+3, r25	; 0x03
     7ac:	8a 83       	std	Y+2, r24	; 0x02
     7ae:	80 e0       	ldi	r24, 0x00	; 0
     7b0:	29 c0       	rjmp	.+82     	; 0x804 <prvCopyDataToQueue+0xb0>
     7b2:	50 e0       	ldi	r21, 0x00	; 0
     7b4:	8e 81       	ldd	r24, Y+6	; 0x06
     7b6:	9f 81       	ldd	r25, Y+7	; 0x07
     7b8:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <memcpy>
     7bc:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	91 95       	neg	r25
     7c2:	81 95       	neg	r24
     7c4:	91 09       	sbc	r25, r1
     7c6:	2e 81       	ldd	r18, Y+6	; 0x06
     7c8:	3f 81       	ldd	r19, Y+7	; 0x07
     7ca:	28 0f       	add	r18, r24
     7cc:	39 1f       	adc	r19, r25
     7ce:	3f 83       	std	Y+7, r19	; 0x07
     7d0:	2e 83       	std	Y+6, r18	; 0x06
     7d2:	48 81       	ld	r20, Y
     7d4:	59 81       	ldd	r21, Y+1	; 0x01
     7d6:	24 17       	cp	r18, r20
     7d8:	35 07       	cpc	r19, r21
     7da:	30 f4       	brcc	.+12     	; 0x7e8 <prvCopyDataToQueue+0x94>
     7dc:	2c 81       	ldd	r18, Y+4	; 0x04
     7de:	3d 81       	ldd	r19, Y+5	; 0x05
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	9f 83       	std	Y+7, r25	; 0x07
     7e6:	8e 83       	std	Y+6, r24	; 0x06
     7e8:	02 30       	cpi	r16, 0x02	; 2
     7ea:	49 f4       	brne	.+18     	; 0x7fe <prvCopyDataToQueue+0xaa>
     7ec:	11 23       	and	r17, r17
     7ee:	49 f0       	breq	.+18     	; 0x802 <prvCopyDataToQueue+0xae>
     7f0:	11 50       	subi	r17, 0x01	; 1
     7f2:	80 e0       	ldi	r24, 0x00	; 0
     7f4:	07 c0       	rjmp	.+14     	; 0x804 <prvCopyDataToQueue+0xb0>
     7f6:	80 e0       	ldi	r24, 0x00	; 0
     7f8:	05 c0       	rjmp	.+10     	; 0x804 <prvCopyDataToQueue+0xb0>
     7fa:	80 e0       	ldi	r24, 0x00	; 0
     7fc:	03 c0       	rjmp	.+6      	; 0x804 <prvCopyDataToQueue+0xb0>
     7fe:	80 e0       	ldi	r24, 0x00	; 0
     800:	01 c0       	rjmp	.+2      	; 0x804 <prvCopyDataToQueue+0xb0>
     802:	80 e0       	ldi	r24, 0x00	; 0
     804:	1f 5f       	subi	r17, 0xFF	; 255
     806:	1a 8f       	std	Y+26, r17	; 0x1a
     808:	df 91       	pop	r29
     80a:	cf 91       	pop	r28
     80c:	1f 91       	pop	r17
     80e:	0f 91       	pop	r16
     810:	08 95       	ret

00000812 <prvUnlockQueue>:
     812:	ef 92       	push	r14
     814:	ff 92       	push	r15
     816:	0f 93       	push	r16
     818:	1f 93       	push	r17
     81a:	cf 93       	push	r28
     81c:	8c 01       	movw	r16, r24
     81e:	0f b6       	in	r0, 0x3f	; 63
     820:	f8 94       	cli
     822:	0f 92       	push	r0
     824:	fc 01       	movw	r30, r24
     826:	c6 8d       	ldd	r28, Z+30	; 0x1e
     828:	1c 16       	cp	r1, r28
     82a:	ac f4       	brge	.+42     	; 0x856 <prvUnlockQueue+0x44>
     82c:	81 89       	ldd	r24, Z+17	; 0x11
     82e:	81 11       	cpse	r24, r1
     830:	06 c0       	rjmp	.+12     	; 0x83e <prvUnlockQueue+0x2c>
     832:	11 c0       	rjmp	.+34     	; 0x856 <prvUnlockQueue+0x44>
     834:	f8 01       	movw	r30, r16
     836:	81 89       	ldd	r24, Z+17	; 0x11
     838:	81 11       	cpse	r24, r1
     83a:	05 c0       	rjmp	.+10     	; 0x846 <prvUnlockQueue+0x34>
     83c:	0c c0       	rjmp	.+24     	; 0x856 <prvUnlockQueue+0x44>
     83e:	78 01       	movw	r14, r16
     840:	f1 e1       	ldi	r31, 0x11	; 17
     842:	ef 0e       	add	r14, r31
     844:	f1 1c       	adc	r15, r1
     846:	c7 01       	movw	r24, r14
     848:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <xTaskRemoveFromEventList>
     84c:	81 11       	cpse	r24, r1
     84e:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <vTaskMissedYield>
     852:	c1 50       	subi	r28, 0x01	; 1
     854:	79 f7       	brne	.-34     	; 0x834 <prvUnlockQueue+0x22>
     856:	8f ef       	ldi	r24, 0xFF	; 255
     858:	f8 01       	movw	r30, r16
     85a:	86 8f       	std	Z+30, r24	; 0x1e
     85c:	0f 90       	pop	r0
     85e:	0f be       	out	0x3f, r0	; 63
     860:	0f b6       	in	r0, 0x3f	; 63
     862:	f8 94       	cli
     864:	0f 92       	push	r0
     866:	c5 8d       	ldd	r28, Z+29	; 0x1d
     868:	1c 16       	cp	r1, r28
     86a:	ac f4       	brge	.+42     	; 0x896 <__stack+0x37>
     86c:	80 85       	ldd	r24, Z+8	; 0x08
     86e:	81 11       	cpse	r24, r1
     870:	06 c0       	rjmp	.+12     	; 0x87e <__stack+0x1f>
     872:	11 c0       	rjmp	.+34     	; 0x896 <__stack+0x37>
     874:	f8 01       	movw	r30, r16
     876:	80 85       	ldd	r24, Z+8	; 0x08
     878:	81 11       	cpse	r24, r1
     87a:	05 c0       	rjmp	.+10     	; 0x886 <__stack+0x27>
     87c:	0c c0       	rjmp	.+24     	; 0x896 <__stack+0x37>
     87e:	78 01       	movw	r14, r16
     880:	f8 e0       	ldi	r31, 0x08	; 8
     882:	ef 0e       	add	r14, r31
     884:	f1 1c       	adc	r15, r1
     886:	c7 01       	movw	r24, r14
     888:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <xTaskRemoveFromEventList>
     88c:	81 11       	cpse	r24, r1
     88e:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <vTaskMissedYield>
     892:	c1 50       	subi	r28, 0x01	; 1
     894:	79 f7       	brne	.-34     	; 0x874 <__stack+0x15>
     896:	8f ef       	ldi	r24, 0xFF	; 255
     898:	f8 01       	movw	r30, r16
     89a:	85 8f       	std	Z+29, r24	; 0x1d
     89c:	0f 90       	pop	r0
     89e:	0f be       	out	0x3f, r0	; 63
     8a0:	cf 91       	pop	r28
     8a2:	1f 91       	pop	r17
     8a4:	0f 91       	pop	r16
     8a6:	ff 90       	pop	r15
     8a8:	ef 90       	pop	r14
     8aa:	08 95       	ret

000008ac <xQueueGenericReset>:
     8ac:	cf 93       	push	r28
     8ae:	df 93       	push	r29
     8b0:	ec 01       	movw	r28, r24
     8b2:	0f b6       	in	r0, 0x3f	; 63
     8b4:	f8 94       	cli
     8b6:	0f 92       	push	r0
     8b8:	e8 81       	ld	r30, Y
     8ba:	f9 81       	ldd	r31, Y+1	; 0x01
     8bc:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8be:	2c 8d       	ldd	r18, Y+28	; 0x1c
     8c0:	90 e0       	ldi	r25, 0x00	; 0
     8c2:	30 e0       	ldi	r19, 0x00	; 0
     8c4:	82 9f       	mul	r24, r18
     8c6:	a0 01       	movw	r20, r0
     8c8:	83 9f       	mul	r24, r19
     8ca:	50 0d       	add	r21, r0
     8cc:	92 9f       	mul	r25, r18
     8ce:	50 0d       	add	r21, r0
     8d0:	11 24       	eor	r1, r1
     8d2:	4e 0f       	add	r20, r30
     8d4:	5f 1f       	adc	r21, r31
     8d6:	5d 83       	std	Y+5, r21	; 0x05
     8d8:	4c 83       	std	Y+4, r20	; 0x04
     8da:	1a 8e       	std	Y+26, r1	; 0x1a
     8dc:	fb 83       	std	Y+3, r31	; 0x03
     8de:	ea 83       	std	Y+2, r30	; 0x02
     8e0:	01 97       	sbiw	r24, 0x01	; 1
     8e2:	82 9f       	mul	r24, r18
     8e4:	a0 01       	movw	r20, r0
     8e6:	83 9f       	mul	r24, r19
     8e8:	50 0d       	add	r21, r0
     8ea:	92 9f       	mul	r25, r18
     8ec:	50 0d       	add	r21, r0
     8ee:	11 24       	eor	r1, r1
     8f0:	cf 01       	movw	r24, r30
     8f2:	84 0f       	add	r24, r20
     8f4:	95 1f       	adc	r25, r21
     8f6:	9f 83       	std	Y+7, r25	; 0x07
     8f8:	8e 83       	std	Y+6, r24	; 0x06
     8fa:	8f ef       	ldi	r24, 0xFF	; 255
     8fc:	8d 8f       	std	Y+29, r24	; 0x1d
     8fe:	8e 8f       	std	Y+30, r24	; 0x1e
     900:	61 11       	cpse	r22, r1
     902:	0c c0       	rjmp	.+24     	; 0x91c <xQueueGenericReset+0x70>
     904:	88 85       	ldd	r24, Y+8	; 0x08
     906:	88 23       	and	r24, r24
     908:	89 f0       	breq	.+34     	; 0x92c <xQueueGenericReset+0x80>
     90a:	ce 01       	movw	r24, r28
     90c:	08 96       	adiw	r24, 0x08	; 8
     90e:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <xTaskRemoveFromEventList>
     912:	88 23       	and	r24, r24
     914:	59 f0       	breq	.+22     	; 0x92c <xQueueGenericReset+0x80>
     916:	0e 94 e7 02 	call	0x5ce	; 0x5ce <vPortYield>
     91a:	08 c0       	rjmp	.+16     	; 0x92c <xQueueGenericReset+0x80>
     91c:	ce 01       	movw	r24, r28
     91e:	08 96       	adiw	r24, 0x08	; 8
     920:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     924:	ce 01       	movw	r24, r28
     926:	41 96       	adiw	r24, 0x11	; 17
     928:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     92c:	0f 90       	pop	r0
     92e:	0f be       	out	0x3f, r0	; 63
     930:	81 e0       	ldi	r24, 0x01	; 1
     932:	df 91       	pop	r29
     934:	cf 91       	pop	r28
     936:	08 95       	ret

00000938 <xQueueGenericCreate>:
     938:	0f 93       	push	r16
     93a:	1f 93       	push	r17
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
     940:	08 2f       	mov	r16, r24
     942:	16 2f       	mov	r17, r22
     944:	86 9f       	mul	r24, r22
     946:	c0 01       	movw	r24, r0
     948:	11 24       	eor	r1, r1
     94a:	4f 96       	adiw	r24, 0x1f	; 31
     94c:	0e 94 85 01 	call	0x30a	; 0x30a <pvPortMalloc>
     950:	ec 01       	movw	r28, r24
     952:	00 97       	sbiw	r24, 0x00	; 0
     954:	71 f0       	breq	.+28     	; 0x972 <xQueueGenericCreate+0x3a>
     956:	11 11       	cpse	r17, r1
     958:	03 c0       	rjmp	.+6      	; 0x960 <xQueueGenericCreate+0x28>
     95a:	99 83       	std	Y+1, r25	; 0x01
     95c:	88 83       	st	Y, r24
     95e:	03 c0       	rjmp	.+6      	; 0x966 <xQueueGenericCreate+0x2e>
     960:	4f 96       	adiw	r24, 0x1f	; 31
     962:	99 83       	std	Y+1, r25	; 0x01
     964:	88 83       	st	Y, r24
     966:	0b 8f       	std	Y+27, r16	; 0x1b
     968:	1c 8f       	std	Y+28, r17	; 0x1c
     96a:	61 e0       	ldi	r22, 0x01	; 1
     96c:	ce 01       	movw	r24, r28
     96e:	0e 94 56 04 	call	0x8ac	; 0x8ac <xQueueGenericReset>
     972:	ce 01       	movw	r24, r28
     974:	df 91       	pop	r29
     976:	cf 91       	pop	r28
     978:	1f 91       	pop	r17
     97a:	0f 91       	pop	r16
     97c:	08 95       	ret

0000097e <xQueueGenericSend>:
     97e:	9f 92       	push	r9
     980:	af 92       	push	r10
     982:	bf 92       	push	r11
     984:	cf 92       	push	r12
     986:	df 92       	push	r13
     988:	ef 92       	push	r14
     98a:	ff 92       	push	r15
     98c:	0f 93       	push	r16
     98e:	1f 93       	push	r17
     990:	cf 93       	push	r28
     992:	df 93       	push	r29
     994:	00 d0       	rcall	.+0      	; 0x996 <xQueueGenericSend+0x18>
     996:	00 d0       	rcall	.+0      	; 0x998 <xQueueGenericSend+0x1a>
     998:	1f 92       	push	r1
     99a:	cd b7       	in	r28, 0x3d	; 61
     99c:	de b7       	in	r29, 0x3e	; 62
     99e:	8c 01       	movw	r16, r24
     9a0:	6b 01       	movw	r12, r22
     9a2:	5d 83       	std	Y+5, r21	; 0x05
     9a4:	4c 83       	std	Y+4, r20	; 0x04
     9a6:	a2 2e       	mov	r10, r18
     9a8:	b1 2c       	mov	r11, r1
     9aa:	99 24       	eor	r9, r9
     9ac:	93 94       	inc	r9
     9ae:	7c 01       	movw	r14, r24
     9b0:	88 e0       	ldi	r24, 0x08	; 8
     9b2:	e8 0e       	add	r14, r24
     9b4:	f1 1c       	adc	r15, r1
     9b6:	0f b6       	in	r0, 0x3f	; 63
     9b8:	f8 94       	cli
     9ba:	0f 92       	push	r0
     9bc:	f8 01       	movw	r30, r16
     9be:	92 8d       	ldd	r25, Z+26	; 0x1a
     9c0:	83 8d       	ldd	r24, Z+27	; 0x1b
     9c2:	98 17       	cp	r25, r24
     9c4:	18 f0       	brcs	.+6      	; 0x9cc <xQueueGenericSend+0x4e>
     9c6:	f2 e0       	ldi	r31, 0x02	; 2
     9c8:	af 12       	cpse	r10, r31
     9ca:	19 c0       	rjmp	.+50     	; 0x9fe <xQueueGenericSend+0x80>
     9cc:	4a 2d       	mov	r20, r10
     9ce:	b6 01       	movw	r22, r12
     9d0:	c8 01       	movw	r24, r16
     9d2:	0e 94 aa 03 	call	0x754	; 0x754 <prvCopyDataToQueue>
     9d6:	f8 01       	movw	r30, r16
     9d8:	91 89       	ldd	r25, Z+17	; 0x11
     9da:	99 23       	and	r25, r25
     9dc:	49 f0       	breq	.+18     	; 0x9f0 <xQueueGenericSend+0x72>
     9de:	c8 01       	movw	r24, r16
     9e0:	41 96       	adiw	r24, 0x11	; 17
     9e2:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <xTaskRemoveFromEventList>
     9e6:	88 23       	and	r24, r24
     9e8:	31 f0       	breq	.+12     	; 0x9f6 <xQueueGenericSend+0x78>
     9ea:	0e 94 e7 02 	call	0x5ce	; 0x5ce <vPortYield>
     9ee:	03 c0       	rjmp	.+6      	; 0x9f6 <xQueueGenericSend+0x78>
     9f0:	81 11       	cpse	r24, r1
     9f2:	0e 94 e7 02 	call	0x5ce	; 0x5ce <vPortYield>
     9f6:	0f 90       	pop	r0
     9f8:	0f be       	out	0x3f, r0	; 63
     9fa:	81 e0       	ldi	r24, 0x01	; 1
     9fc:	50 c0       	rjmp	.+160    	; 0xa9e <xQueueGenericSend+0x120>
     9fe:	8c 81       	ldd	r24, Y+4	; 0x04
     a00:	9d 81       	ldd	r25, Y+5	; 0x05
     a02:	89 2b       	or	r24, r25
     a04:	21 f4       	brne	.+8      	; 0xa0e <xQueueGenericSend+0x90>
     a06:	0f 90       	pop	r0
     a08:	0f be       	out	0x3f, r0	; 63
     a0a:	80 e0       	ldi	r24, 0x00	; 0
     a0c:	48 c0       	rjmp	.+144    	; 0xa9e <xQueueGenericSend+0x120>
     a0e:	b1 10       	cpse	r11, r1
     a10:	05 c0       	rjmp	.+10     	; 0xa1c <xQueueGenericSend+0x9e>
     a12:	ce 01       	movw	r24, r28
     a14:	01 96       	adiw	r24, 0x01	; 1
     a16:	0e 94 99 0a 	call	0x1532	; 0x1532 <vTaskInternalSetTimeOutState>
     a1a:	b9 2c       	mov	r11, r9
     a1c:	0f 90       	pop	r0
     a1e:	0f be       	out	0x3f, r0	; 63
     a20:	0e 94 7d 08 	call	0x10fa	; 0x10fa <vTaskSuspendAll>
     a24:	0f b6       	in	r0, 0x3f	; 63
     a26:	f8 94       	cli
     a28:	0f 92       	push	r0
     a2a:	f8 01       	movw	r30, r16
     a2c:	85 8d       	ldd	r24, Z+29	; 0x1d
     a2e:	8f 3f       	cpi	r24, 0xFF	; 255
     a30:	09 f4       	brne	.+2      	; 0xa34 <xQueueGenericSend+0xb6>
     a32:	15 8e       	std	Z+29, r1	; 0x1d
     a34:	f8 01       	movw	r30, r16
     a36:	86 8d       	ldd	r24, Z+30	; 0x1e
     a38:	8f 3f       	cpi	r24, 0xFF	; 255
     a3a:	09 f4       	brne	.+2      	; 0xa3e <xQueueGenericSend+0xc0>
     a3c:	16 8e       	std	Z+30, r1	; 0x1e
     a3e:	0f 90       	pop	r0
     a40:	0f be       	out	0x3f, r0	; 63
     a42:	be 01       	movw	r22, r28
     a44:	6c 5f       	subi	r22, 0xFC	; 252
     a46:	7f 4f       	sbci	r23, 0xFF	; 255
     a48:	ce 01       	movw	r24, r28
     a4a:	01 96       	adiw	r24, 0x01	; 1
     a4c:	0e 94 a4 0a 	call	0x1548	; 0x1548 <xTaskCheckForTimeOut>
     a50:	81 11       	cpse	r24, r1
     a52:	1f c0       	rjmp	.+62     	; 0xa92 <xQueueGenericSend+0x114>
     a54:	0f b6       	in	r0, 0x3f	; 63
     a56:	f8 94       	cli
     a58:	0f 92       	push	r0
     a5a:	f8 01       	movw	r30, r16
     a5c:	92 8d       	ldd	r25, Z+26	; 0x1a
     a5e:	0f 90       	pop	r0
     a60:	0f be       	out	0x3f, r0	; 63
     a62:	83 8d       	ldd	r24, Z+27	; 0x1b
     a64:	98 13       	cpse	r25, r24
     a66:	0f c0       	rjmp	.+30     	; 0xa86 <xQueueGenericSend+0x108>
     a68:	6c 81       	ldd	r22, Y+4	; 0x04
     a6a:	7d 81       	ldd	r23, Y+5	; 0x05
     a6c:	c7 01       	movw	r24, r14
     a6e:	0e 94 3f 0a 	call	0x147e	; 0x147e <vTaskPlaceOnEventList>
     a72:	c8 01       	movw	r24, r16
     a74:	0e 94 09 04 	call	0x812	; 0x812 <prvUnlockQueue>
     a78:	0e 94 42 09 	call	0x1284	; 0x1284 <xTaskResumeAll>
     a7c:	81 11       	cpse	r24, r1
     a7e:	9b cf       	rjmp	.-202    	; 0x9b6 <xQueueGenericSend+0x38>
     a80:	0e 94 e7 02 	call	0x5ce	; 0x5ce <vPortYield>
     a84:	98 cf       	rjmp	.-208    	; 0x9b6 <xQueueGenericSend+0x38>
     a86:	c8 01       	movw	r24, r16
     a88:	0e 94 09 04 	call	0x812	; 0x812 <prvUnlockQueue>
     a8c:	0e 94 42 09 	call	0x1284	; 0x1284 <xTaskResumeAll>
     a90:	92 cf       	rjmp	.-220    	; 0x9b6 <xQueueGenericSend+0x38>
     a92:	c8 01       	movw	r24, r16
     a94:	0e 94 09 04 	call	0x812	; 0x812 <prvUnlockQueue>
     a98:	0e 94 42 09 	call	0x1284	; 0x1284 <xTaskResumeAll>
     a9c:	80 e0       	ldi	r24, 0x00	; 0
     a9e:	0f 90       	pop	r0
     aa0:	0f 90       	pop	r0
     aa2:	0f 90       	pop	r0
     aa4:	0f 90       	pop	r0
     aa6:	0f 90       	pop	r0
     aa8:	df 91       	pop	r29
     aaa:	cf 91       	pop	r28
     aac:	1f 91       	pop	r17
     aae:	0f 91       	pop	r16
     ab0:	ff 90       	pop	r15
     ab2:	ef 90       	pop	r14
     ab4:	df 90       	pop	r13
     ab6:	cf 90       	pop	r12
     ab8:	bf 90       	pop	r11
     aba:	af 90       	pop	r10
     abc:	9f 90       	pop	r9
     abe:	08 95       	ret

00000ac0 <xQueueCreateMutex>:
     ac0:	cf 93       	push	r28
     ac2:	df 93       	push	r29
     ac4:	48 2f       	mov	r20, r24
     ac6:	60 e0       	ldi	r22, 0x00	; 0
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	0e 94 9c 04 	call	0x938	; 0x938 <xQueueGenericCreate>
     ace:	ec 01       	movw	r28, r24
     ad0:	00 97       	sbiw	r24, 0x00	; 0
     ad2:	61 f0       	breq	.+24     	; 0xaec <xQueueCreateMutex+0x2c>
     ad4:	1d 82       	std	Y+5, r1	; 0x05
     ad6:	1c 82       	std	Y+4, r1	; 0x04
     ad8:	19 82       	std	Y+1, r1	; 0x01
     ada:	18 82       	st	Y, r1
     adc:	1e 82       	std	Y+6, r1	; 0x06
     ade:	20 e0       	ldi	r18, 0x00	; 0
     ae0:	40 e0       	ldi	r20, 0x00	; 0
     ae2:	50 e0       	ldi	r21, 0x00	; 0
     ae4:	60 e0       	ldi	r22, 0x00	; 0
     ae6:	70 e0       	ldi	r23, 0x00	; 0
     ae8:	0e 94 bf 04 	call	0x97e	; 0x97e <xQueueGenericSend>
     aec:	ce 01       	movw	r24, r28
     aee:	df 91       	pop	r29
     af0:	cf 91       	pop	r28
     af2:	08 95       	ret

00000af4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
     af4:	bf 92       	push	r11
     af6:	cf 92       	push	r12
     af8:	df 92       	push	r13
     afa:	ef 92       	push	r14
     afc:	ff 92       	push	r15
     afe:	0f 93       	push	r16
     b00:	1f 93       	push	r17
     b02:	cf 93       	push	r28
     b04:	df 93       	push	r29
     b06:	00 d0       	rcall	.+0      	; 0xb08 <xQueueSemaphoreTake+0x14>
     b08:	00 d0       	rcall	.+0      	; 0xb0a <xQueueSemaphoreTake+0x16>
     b0a:	1f 92       	push	r1
     b0c:	cd b7       	in	r28, 0x3d	; 61
     b0e:	de b7       	in	r29, 0x3e	; 62
     b10:	8c 01       	movw	r16, r24
     b12:	7d 83       	std	Y+5, r23	; 0x05
     b14:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
     b16:	b1 2c       	mov	r11, r1
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
BaseType_t xEntryTimeSet = pdFALSE;
     b18:	d1 2c       	mov	r13, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     b1a:	cc 24       	eor	r12, r12
     b1c:	c3 94       	inc	r12
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b1e:	7c 01       	movw	r14, r24
     b20:	81 e1       	ldi	r24, 0x11	; 17
     b22:	e8 0e       	add	r14, r24
     b24:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     b26:	0f b6       	in	r0, 0x3f	; 63
     b28:	f8 94       	cli
     b2a:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
     b2c:	d8 01       	movw	r26, r16
     b2e:	5a 96       	adiw	r26, 0x1a	; 26
     b30:	8c 91       	ld	r24, X
     b32:	5a 97       	sbiw	r26, 0x1a	; 26

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
     b34:	88 23       	and	r24, r24
     b36:	e9 f0       	breq	.+58     	; 0xb72 <xQueueSemaphoreTake+0x7e>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
     b38:	81 50       	subi	r24, 0x01	; 1
     b3a:	5a 96       	adiw	r26, 0x1a	; 26
     b3c:	8c 93       	st	X, r24
     b3e:	5a 97       	sbiw	r26, 0x1a	; 26

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b40:	8d 91       	ld	r24, X+
     b42:	9c 91       	ld	r25, X
     b44:	89 2b       	or	r24, r25
     b46:	29 f4       	brne	.+10     	; 0xb52 <xQueueSemaphoreTake+0x5e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
     b48:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <pvTaskIncrementMutexHeldCount>
     b4c:	f8 01       	movw	r30, r16
     b4e:	95 83       	std	Z+5, r25	; 0x05
     b50:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b52:	d8 01       	movw	r26, r16
     b54:	18 96       	adiw	r26, 0x08	; 8
     b56:	8c 91       	ld	r24, X
     b58:	88 23       	and	r24, r24
     b5a:	39 f0       	breq	.+14     	; 0xb6a <xQueueSemaphoreTake+0x76>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b5c:	c8 01       	movw	r24, r16
     b5e:	08 96       	adiw	r24, 0x08	; 8
     b60:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <xTaskRemoveFromEventList>
     b64:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
     b66:	0e 94 e7 02 	call	0x5ce	; 0x5ce <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
     b6a:	0f 90       	pop	r0
     b6c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     b6e:	81 e0       	ldi	r24, 0x01	; 1
     b70:	7f c0       	rjmp	.+254    	; 0xc70 <xQueueSemaphoreTake+0x17c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     b72:	8c 81       	ldd	r24, Y+4	; 0x04
     b74:	9d 81       	ldd	r25, Y+5	; 0x05
     b76:	89 2b       	or	r24, r25
     b78:	21 f4       	brne	.+8      	; 0xb82 <xQueueSemaphoreTake+0x8e>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
     b7a:	0f 90       	pop	r0
     b7c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	77 c0       	rjmp	.+238    	; 0xc70 <xQueueSemaphoreTake+0x17c>
				}
				else if( xEntryTimeSet == pdFALSE )
     b82:	d1 10       	cpse	r13, r1
     b84:	05 c0       	rjmp	.+10     	; 0xb90 <xQueueSemaphoreTake+0x9c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
     b86:	ce 01       	movw	r24, r28
     b88:	01 96       	adiw	r24, 0x01	; 1
     b8a:	0e 94 99 0a 	call	0x1532	; 0x1532 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b8e:	dc 2c       	mov	r13, r12
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b90:	0f 90       	pop	r0
     b92:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
     b94:	0e 94 7d 08 	call	0x10fa	; 0x10fa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b98:	0f b6       	in	r0, 0x3f	; 63
     b9a:	f8 94       	cli
     b9c:	0f 92       	push	r0
     b9e:	f8 01       	movw	r30, r16
     ba0:	85 8d       	ldd	r24, Z+29	; 0x1d
     ba2:	8f 3f       	cpi	r24, 0xFF	; 255
     ba4:	09 f4       	brne	.+2      	; 0xba8 <xQueueSemaphoreTake+0xb4>
     ba6:	15 8e       	std	Z+29, r1	; 0x1d
     ba8:	d8 01       	movw	r26, r16
     baa:	5e 96       	adiw	r26, 0x1e	; 30
     bac:	8c 91       	ld	r24, X
     bae:	5e 97       	sbiw	r26, 0x1e	; 30
     bb0:	8f 3f       	cpi	r24, 0xFF	; 255
     bb2:	11 f4       	brne	.+4      	; 0xbb8 <xQueueSemaphoreTake+0xc4>
     bb4:	5e 96       	adiw	r26, 0x1e	; 30
     bb6:	1c 92       	st	X, r1
     bb8:	0f 90       	pop	r0
     bba:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     bbc:	be 01       	movw	r22, r28
     bbe:	6c 5f       	subi	r22, 0xFC	; 252
     bc0:	7f 4f       	sbci	r23, 0xFF	; 255
     bc2:	ce 01       	movw	r24, r28
     bc4:	01 96       	adiw	r24, 0x01	; 1
     bc6:	0e 94 a4 0a 	call	0x1548	; 0x1548 <xTaskCheckForTimeOut>
     bca:	81 11       	cpse	r24, r1
     bcc:	29 c0       	rjmp	.+82     	; 0xc20 <xQueueSemaphoreTake+0x12c>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     bce:	c8 01       	movw	r24, r16
     bd0:	0e 94 9f 03 	call	0x73e	; 0x73e <prvIsQueueEmpty>
     bd4:	88 23       	and	r24, r24
     bd6:	f1 f0       	breq	.+60     	; 0xc14 <xQueueSemaphoreTake+0x120>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     bd8:	f8 01       	movw	r30, r16
     bda:	80 81       	ld	r24, Z
     bdc:	91 81       	ldd	r25, Z+1	; 0x01
     bde:	89 2b       	or	r24, r25
     be0:	51 f4       	brne	.+20     	; 0xbf6 <xQueueSemaphoreTake+0x102>
					{
						taskENTER_CRITICAL();
     be2:	0f b6       	in	r0, 0x3f	; 63
     be4:	f8 94       	cli
     be6:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
     be8:	84 81       	ldd	r24, Z+4	; 0x04
     bea:	95 81       	ldd	r25, Z+5	; 0x05
     bec:	0e 94 de 0a 	call	0x15bc	; 0x15bc <xTaskPriorityInherit>
     bf0:	b8 2e       	mov	r11, r24
						}
						taskEXIT_CRITICAL();
     bf2:	0f 90       	pop	r0
     bf4:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     bf6:	6c 81       	ldd	r22, Y+4	; 0x04
     bf8:	7d 81       	ldd	r23, Y+5	; 0x05
     bfa:	c7 01       	movw	r24, r14
     bfc:	0e 94 3f 0a 	call	0x147e	; 0x147e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     c00:	c8 01       	movw	r24, r16
     c02:	0e 94 09 04 	call	0x812	; 0x812 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     c06:	0e 94 42 09 	call	0x1284	; 0x1284 <xTaskResumeAll>
     c0a:	81 11       	cpse	r24, r1
     c0c:	8c cf       	rjmp	.-232    	; 0xb26 <xQueueSemaphoreTake+0x32>
				{
					portYIELD_WITHIN_API();
     c0e:	0e 94 e7 02 	call	0x5ce	; 0x5ce <vPortYield>
     c12:	89 cf       	rjmp	.-238    	; 0xb26 <xQueueSemaphoreTake+0x32>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
     c14:	c8 01       	movw	r24, r16
     c16:	0e 94 09 04 	call	0x812	; 0x812 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     c1a:	0e 94 42 09 	call	0x1284	; 0x1284 <xTaskResumeAll>
     c1e:	83 cf       	rjmp	.-250    	; 0xb26 <xQueueSemaphoreTake+0x32>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
     c20:	c8 01       	movw	r24, r16
     c22:	0e 94 09 04 	call	0x812	; 0x812 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     c26:	0e 94 42 09 	call	0x1284	; 0x1284 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     c2a:	c8 01       	movw	r24, r16
     c2c:	0e 94 9f 03 	call	0x73e	; 0x73e <prvIsQueueEmpty>
     c30:	88 23       	and	r24, r24
     c32:	09 f4       	brne	.+2      	; 0xc36 <xQueueSemaphoreTake+0x142>
     c34:	78 cf       	rjmp	.-272    	; 0xb26 <xQueueSemaphoreTake+0x32>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
     c36:	bb 20       	and	r11, r11
     c38:	d1 f0       	breq	.+52     	; 0xc6e <xQueueSemaphoreTake+0x17a>
					{
						taskENTER_CRITICAL();
     c3a:	0f b6       	in	r0, 0x3f	; 63
     c3c:	f8 94       	cli
     c3e:	0f 92       	push	r0
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
     c40:	f8 01       	movw	r30, r16
     c42:	81 89       	ldd	r24, Z+17	; 0x11
     c44:	88 23       	and	r24, r24
     c46:	39 f0       	breq	.+14     	; 0xc56 <xQueueSemaphoreTake+0x162>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
     c48:	06 88       	ldd	r0, Z+22	; 0x16
     c4a:	f7 89       	ldd	r31, Z+23	; 0x17
     c4c:	e0 2d       	mov	r30, r0
     c4e:	80 81       	ld	r24, Z
     c50:	64 e0       	ldi	r22, 0x04	; 4
     c52:	68 1b       	sub	r22, r24
     c54:	01 c0       	rjmp	.+2      	; 0xc58 <xQueueSemaphoreTake+0x164>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
     c56:	60 e0       	ldi	r22, 0x00	; 0
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
     c58:	d8 01       	movw	r26, r16
     c5a:	14 96       	adiw	r26, 0x04	; 4
     c5c:	8d 91       	ld	r24, X+
     c5e:	9c 91       	ld	r25, X
     c60:	15 97       	sbiw	r26, 0x05	; 5
     c62:	0e 94 90 0b 	call	0x1720	; 0x1720 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
     c66:	0f 90       	pop	r0
     c68:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     c6a:	80 e0       	ldi	r24, 0x00	; 0
     c6c:	01 c0       	rjmp	.+2      	; 0xc70 <xQueueSemaphoreTake+0x17c>
     c6e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
     c70:	0f 90       	pop	r0
     c72:	0f 90       	pop	r0
     c74:	0f 90       	pop	r0
     c76:	0f 90       	pop	r0
     c78:	0f 90       	pop	r0
     c7a:	df 91       	pop	r29
     c7c:	cf 91       	pop	r28
     c7e:	1f 91       	pop	r17
     c80:	0f 91       	pop	r16
     c82:	ff 90       	pop	r15
     c84:	ef 90       	pop	r14
     c86:	df 90       	pop	r13
     c88:	cf 90       	pop	r12
     c8a:	bf 90       	pop	r11
     c8c:	08 95       	ret

00000c8e <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     c8e:	e0 91 1b 03 	lds	r30, 0x031B	; 0x80031b <pxDelayedTaskList>
     c92:	f0 91 1c 03 	lds	r31, 0x031C	; 0x80031c <pxDelayedTaskList+0x1>
     c96:	80 81       	ld	r24, Z
     c98:	81 11       	cpse	r24, r1
     c9a:	07 c0       	rjmp	.+14     	; 0xcaa <prvResetNextTaskUnblockTime+0x1c>
     c9c:	8f ef       	ldi	r24, 0xFF	; 255
     c9e:	9f ef       	ldi	r25, 0xFF	; 255
     ca0:	90 93 f2 02 	sts	0x02F2, r25	; 0x8002f2 <xNextTaskUnblockTime+0x1>
     ca4:	80 93 f1 02 	sts	0x02F1, r24	; 0x8002f1 <xNextTaskUnblockTime>
     ca8:	08 95       	ret
     caa:	e0 91 1b 03 	lds	r30, 0x031B	; 0x80031b <pxDelayedTaskList>
     cae:	f0 91 1c 03 	lds	r31, 0x031C	; 0x80031c <pxDelayedTaskList+0x1>
     cb2:	05 80       	ldd	r0, Z+5	; 0x05
     cb4:	f6 81       	ldd	r31, Z+6	; 0x06
     cb6:	e0 2d       	mov	r30, r0
     cb8:	06 80       	ldd	r0, Z+6	; 0x06
     cba:	f7 81       	ldd	r31, Z+7	; 0x07
     cbc:	e0 2d       	mov	r30, r0
     cbe:	82 81       	ldd	r24, Z+2	; 0x02
     cc0:	93 81       	ldd	r25, Z+3	; 0x03
     cc2:	90 93 f2 02 	sts	0x02F2, r25	; 0x8002f2 <xNextTaskUnblockTime+0x1>
     cc6:	80 93 f1 02 	sts	0x02F1, r24	; 0x8002f1 <xNextTaskUnblockTime>
     cca:	08 95       	ret

00000ccc <prvIdleTask>:
     ccc:	07 e0       	ldi	r16, 0x07	; 7
     cce:	13 e0       	ldi	r17, 0x03	; 3
     cd0:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <uxDeletedTasksWaitingCleanUp>
     cd4:	88 23       	and	r24, r24
     cd6:	e1 f3       	breq	.-8      	; 0xcd0 <prvIdleTask+0x4>
     cd8:	0f b6       	in	r0, 0x3f	; 63
     cda:	f8 94       	cli
     cdc:	0f 92       	push	r0
     cde:	d8 01       	movw	r26, r16
     ce0:	15 96       	adiw	r26, 0x05	; 5
     ce2:	ed 91       	ld	r30, X+
     ce4:	fc 91       	ld	r31, X
     ce6:	16 97       	sbiw	r26, 0x06	; 6
     ce8:	c6 81       	ldd	r28, Z+6	; 0x06
     cea:	d7 81       	ldd	r29, Z+7	; 0x07
     cec:	ce 01       	movw	r24, r28
     cee:	02 96       	adiw	r24, 0x02	; 2
     cf0:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
     cf4:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <uxCurrentNumberOfTasks>
     cf8:	81 50       	subi	r24, 0x01	; 1
     cfa:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <uxCurrentNumberOfTasks>
     cfe:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <uxDeletedTasksWaitingCleanUp>
     d02:	81 50       	subi	r24, 0x01	; 1
     d04:	80 93 06 03 	sts	0x0306, r24	; 0x800306 <uxDeletedTasksWaitingCleanUp>
     d08:	0f 90       	pop	r0
     d0a:	0f be       	out	0x3f, r0	; 63
     d0c:	8f 89       	ldd	r24, Y+23	; 0x17
     d0e:	98 8d       	ldd	r25, Y+24	; 0x18
     d10:	0e 94 ba 01 	call	0x374	; 0x374 <vPortFree>
     d14:	ce 01       	movw	r24, r28
     d16:	0e 94 ba 01 	call	0x374	; 0x374 <vPortFree>
     d1a:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <uxDeletedTasksWaitingCleanUp>
     d1e:	81 11       	cpse	r24, r1
     d20:	db cf       	rjmp	.-74     	; 0xcd8 <prvIdleTask+0xc>
     d22:	d6 cf       	rjmp	.-84     	; 0xcd0 <prvIdleTask+0x4>

00000d24 <prvAddCurrentTaskToDelayedList>:
     d24:	ff 92       	push	r15
     d26:	0f 93       	push	r16
     d28:	1f 93       	push	r17
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	ec 01       	movw	r28, r24
     d30:	f6 2e       	mov	r15, r22
     d32:	00 91 fa 02 	lds	r16, 0x02FA	; 0x8002fa <xTickCount>
     d36:	10 91 fb 02 	lds	r17, 0x02FB	; 0x8002fb <xTickCount+0x1>
     d3a:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <pxCurrentTCB>
     d3e:	90 91 54 03 	lds	r25, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     d42:	02 96       	adiw	r24, 0x02	; 2
     d44:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
     d48:	cf 3f       	cpi	r28, 0xFF	; 255
     d4a:	8f ef       	ldi	r24, 0xFF	; 255
     d4c:	d8 07       	cpc	r29, r24
     d4e:	69 f4       	brne	.+26     	; 0xd6a <prvAddCurrentTaskToDelayedList+0x46>
     d50:	ff 20       	and	r15, r15
     d52:	59 f0       	breq	.+22     	; 0xd6a <prvAddCurrentTaskToDelayedList+0x46>
     d54:	60 91 53 03 	lds	r22, 0x0353	; 0x800353 <pxCurrentTCB>
     d58:	70 91 54 03 	lds	r23, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     d5c:	6e 5f       	subi	r22, 0xFE	; 254
     d5e:	7f 4f       	sbci	r23, 0xFF	; 255
     d60:	8d ef       	ldi	r24, 0xFD	; 253
     d62:	92 e0       	ldi	r25, 0x02	; 2
     d64:	0e 94 cd 01 	call	0x39a	; 0x39a <vListInsertEnd>
     d68:	2f c0       	rjmp	.+94     	; 0xdc8 <prvAddCurrentTaskToDelayedList+0xa4>
     d6a:	c0 0f       	add	r28, r16
     d6c:	d1 1f       	adc	r29, r17
     d6e:	e0 91 53 03 	lds	r30, 0x0353	; 0x800353 <pxCurrentTCB>
     d72:	f0 91 54 03 	lds	r31, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     d76:	d3 83       	std	Z+3, r29	; 0x03
     d78:	c2 83       	std	Z+2, r28	; 0x02
     d7a:	c0 17       	cp	r28, r16
     d7c:	d1 07       	cpc	r29, r17
     d7e:	68 f4       	brcc	.+26     	; 0xd9a <prvAddCurrentTaskToDelayedList+0x76>
     d80:	60 91 53 03 	lds	r22, 0x0353	; 0x800353 <pxCurrentTCB>
     d84:	70 91 54 03 	lds	r23, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     d88:	80 91 19 03 	lds	r24, 0x0319	; 0x800319 <pxOverflowDelayedTaskList>
     d8c:	90 91 1a 03 	lds	r25, 0x031A	; 0x80031a <pxOverflowDelayedTaskList+0x1>
     d90:	6e 5f       	subi	r22, 0xFE	; 254
     d92:	7f 4f       	sbci	r23, 0xFF	; 255
     d94:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vListInsert>
     d98:	17 c0       	rjmp	.+46     	; 0xdc8 <prvAddCurrentTaskToDelayedList+0xa4>
     d9a:	60 91 53 03 	lds	r22, 0x0353	; 0x800353 <pxCurrentTCB>
     d9e:	70 91 54 03 	lds	r23, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     da2:	80 91 1b 03 	lds	r24, 0x031B	; 0x80031b <pxDelayedTaskList>
     da6:	90 91 1c 03 	lds	r25, 0x031C	; 0x80031c <pxDelayedTaskList+0x1>
     daa:	6e 5f       	subi	r22, 0xFE	; 254
     dac:	7f 4f       	sbci	r23, 0xFF	; 255
     dae:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vListInsert>
     db2:	80 91 f1 02 	lds	r24, 0x02F1	; 0x8002f1 <xNextTaskUnblockTime>
     db6:	90 91 f2 02 	lds	r25, 0x02F2	; 0x8002f2 <xNextTaskUnblockTime+0x1>
     dba:	c8 17       	cp	r28, r24
     dbc:	d9 07       	cpc	r29, r25
     dbe:	20 f4       	brcc	.+8      	; 0xdc8 <prvAddCurrentTaskToDelayedList+0xa4>
     dc0:	d0 93 f2 02 	sts	0x02F2, r29	; 0x8002f2 <xNextTaskUnblockTime+0x1>
     dc4:	c0 93 f1 02 	sts	0x02F1, r28	; 0x8002f1 <xNextTaskUnblockTime>
     dc8:	df 91       	pop	r29
     dca:	cf 91       	pop	r28
     dcc:	1f 91       	pop	r17
     dce:	0f 91       	pop	r16
     dd0:	ff 90       	pop	r15
     dd2:	08 95       	ret

00000dd4 <xTaskCreate>:
     dd4:	4f 92       	push	r4
     dd6:	5f 92       	push	r5
     dd8:	6f 92       	push	r6
     dda:	7f 92       	push	r7
     ddc:	8f 92       	push	r8
     dde:	9f 92       	push	r9
     de0:	af 92       	push	r10
     de2:	bf 92       	push	r11
     de4:	cf 92       	push	r12
     de6:	df 92       	push	r13
     de8:	ef 92       	push	r14
     dea:	ff 92       	push	r15
     dec:	0f 93       	push	r16
     dee:	cf 93       	push	r28
     df0:	df 93       	push	r29
     df2:	4c 01       	movw	r8, r24
     df4:	6b 01       	movw	r12, r22
     df6:	5a 01       	movw	r10, r20
     df8:	29 01       	movw	r4, r18
     dfa:	ca 01       	movw	r24, r20
     dfc:	0e 94 85 01 	call	0x30a	; 0x30a <pvPortMalloc>
     e00:	3c 01       	movw	r6, r24
     e02:	89 2b       	or	r24, r25
     e04:	09 f4       	brne	.+2      	; 0xe08 <xTaskCreate+0x34>
     e06:	e9 c0       	rjmp	.+466    	; 0xfda <xTaskCreate+0x206>
     e08:	88 e2       	ldi	r24, 0x28	; 40
     e0a:	90 e0       	ldi	r25, 0x00	; 0
     e0c:	0e 94 85 01 	call	0x30a	; 0x30a <pvPortMalloc>
     e10:	ec 01       	movw	r28, r24
     e12:	89 2b       	or	r24, r25
     e14:	59 f0       	breq	.+22     	; 0xe2c <xTaskCreate+0x58>
     e16:	78 8e       	std	Y+24, r7	; 0x18
     e18:	6f 8a       	std	Y+23, r6	; 0x17
     e1a:	81 e0       	ldi	r24, 0x01	; 1
     e1c:	a8 1a       	sub	r10, r24
     e1e:	b1 08       	sbc	r11, r1
     e20:	6a 0c       	add	r6, r10
     e22:	7b 1c       	adc	r7, r11
     e24:	c1 14       	cp	r12, r1
     e26:	d1 04       	cpc	r13, r1
     e28:	29 f4       	brne	.+10     	; 0xe34 <xTaskCreate+0x60>
     e2a:	20 c0       	rjmp	.+64     	; 0xe6c <xTaskCreate+0x98>
     e2c:	c3 01       	movw	r24, r6
     e2e:	0e 94 ba 01 	call	0x374	; 0x374 <vPortFree>
     e32:	d3 c0       	rjmp	.+422    	; 0xfda <xTaskCreate+0x206>
     e34:	d6 01       	movw	r26, r12
     e36:	8c 91       	ld	r24, X
     e38:	89 8f       	std	Y+25, r24	; 0x19
     e3a:	8c 91       	ld	r24, X
     e3c:	88 23       	and	r24, r24
     e3e:	a1 f0       	breq	.+40     	; 0xe68 <xTaskCreate+0x94>
     e40:	ae 01       	movw	r20, r28
     e42:	46 5e       	subi	r20, 0xE6	; 230
     e44:	5f 4f       	sbci	r21, 0xFF	; 255
     e46:	f6 01       	movw	r30, r12
     e48:	31 96       	adiw	r30, 0x01	; 1
     e4a:	b8 e0       	ldi	r27, 0x08	; 8
     e4c:	cb 0e       	add	r12, r27
     e4e:	d1 1c       	adc	r13, r1
     e50:	cf 01       	movw	r24, r30
     e52:	21 91       	ld	r18, Z+
     e54:	da 01       	movw	r26, r20
     e56:	2d 93       	st	X+, r18
     e58:	ad 01       	movw	r20, r26
     e5a:	dc 01       	movw	r26, r24
     e5c:	8c 91       	ld	r24, X
     e5e:	88 23       	and	r24, r24
     e60:	19 f0       	breq	.+6      	; 0xe68 <xTaskCreate+0x94>
     e62:	ec 15       	cp	r30, r12
     e64:	fd 05       	cpc	r31, r13
     e66:	a1 f7       	brne	.-24     	; 0xe50 <xTaskCreate+0x7c>
     e68:	18 a2       	std	Y+32, r1	; 0x20
     e6a:	01 c0       	rjmp	.+2      	; 0xe6e <xTaskCreate+0x9a>
     e6c:	19 8e       	std	Y+25, r1	; 0x19
     e6e:	04 30       	cpi	r16, 0x04	; 4
     e70:	08 f0       	brcs	.+2      	; 0xe74 <xTaskCreate+0xa0>
     e72:	03 e0       	ldi	r16, 0x03	; 3
     e74:	0e 8b       	std	Y+22, r16	; 0x16
     e76:	09 a3       	std	Y+33, r16	; 0x21
     e78:	1a a2       	std	Y+34, r1	; 0x22
     e7a:	6e 01       	movw	r12, r28
     e7c:	b2 e0       	ldi	r27, 0x02	; 2
     e7e:	cb 0e       	add	r12, r27
     e80:	d1 1c       	adc	r13, r1
     e82:	c6 01       	movw	r24, r12
     e84:	0e 94 c9 01 	call	0x392	; 0x392 <vListInitialiseItem>
     e88:	ce 01       	movw	r24, r28
     e8a:	0c 96       	adiw	r24, 0x0c	; 12
     e8c:	0e 94 c9 01 	call	0x392	; 0x392 <vListInitialiseItem>
     e90:	d9 87       	std	Y+9, r29	; 0x09
     e92:	c8 87       	std	Y+8, r28	; 0x08
     e94:	84 e0       	ldi	r24, 0x04	; 4
     e96:	90 e0       	ldi	r25, 0x00	; 0
     e98:	80 1b       	sub	r24, r16
     e9a:	91 09       	sbc	r25, r1
     e9c:	9d 87       	std	Y+13, r25	; 0x0d
     e9e:	8c 87       	std	Y+12, r24	; 0x0c
     ea0:	db 8b       	std	Y+19, r29	; 0x13
     ea2:	ca 8b       	std	Y+18, r28	; 0x12
     ea4:	1b a2       	std	Y+35, r1	; 0x23
     ea6:	1c a2       	std	Y+36, r1	; 0x24
     ea8:	1d a2       	std	Y+37, r1	; 0x25
     eaa:	1e a2       	std	Y+38, r1	; 0x26
     eac:	1f a2       	std	Y+39, r1	; 0x27
     eae:	a2 01       	movw	r20, r4
     eb0:	b4 01       	movw	r22, r8
     eb2:	c3 01       	movw	r24, r6
     eb4:	0e 94 46 02 	call	0x48c	; 0x48c <pxPortInitialiseStack>
     eb8:	99 83       	std	Y+1, r25	; 0x01
     eba:	88 83       	st	Y, r24
     ebc:	e1 14       	cp	r14, r1
     ebe:	f1 04       	cpc	r15, r1
     ec0:	19 f0       	breq	.+6      	; 0xec8 <xTaskCreate+0xf4>
     ec2:	f7 01       	movw	r30, r14
     ec4:	d1 83       	std	Z+1, r29	; 0x01
     ec6:	c0 83       	st	Z, r28
     ec8:	0f b6       	in	r0, 0x3f	; 63
     eca:	f8 94       	cli
     ecc:	0f 92       	push	r0
     ece:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <uxCurrentNumberOfTasks>
     ed2:	8f 5f       	subi	r24, 0xFF	; 255
     ed4:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <uxCurrentNumberOfTasks>
     ed8:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <pxCurrentTCB>
     edc:	90 91 54 03 	lds	r25, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     ee0:	89 2b       	or	r24, r25
     ee2:	d1 f5       	brne	.+116    	; 0xf58 <xTaskCreate+0x184>
     ee4:	d0 93 54 03 	sts	0x0354, r29	; 0x800354 <pxCurrentTCB+0x1>
     ee8:	c0 93 53 03 	sts	0x0353, r28	; 0x800353 <pxCurrentTCB>
     eec:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <uxCurrentNumberOfTasks>
     ef0:	81 30       	cpi	r24, 0x01	; 1
     ef2:	09 f0       	breq	.+2      	; 0xef6 <xTaskCreate+0x122>
     ef4:	41 c0       	rjmp	.+130    	; 0xf78 <xTaskCreate+0x1a4>
     ef6:	8f e2       	ldi	r24, 0x2F	; 47
     ef8:	93 e0       	ldi	r25, 0x03	; 3
     efa:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     efe:	88 e3       	ldi	r24, 0x38	; 56
     f00:	93 e0       	ldi	r25, 0x03	; 3
     f02:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     f06:	81 e4       	ldi	r24, 0x41	; 65
     f08:	93 e0       	ldi	r25, 0x03	; 3
     f0a:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     f0e:	8a e4       	ldi	r24, 0x4A	; 74
     f10:	93 e0       	ldi	r25, 0x03	; 3
     f12:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     f16:	86 e2       	ldi	r24, 0x26	; 38
     f18:	93 e0       	ldi	r25, 0x03	; 3
     f1a:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     f1e:	8d e1       	ldi	r24, 0x1D	; 29
     f20:	93 e0       	ldi	r25, 0x03	; 3
     f22:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     f26:	80 e1       	ldi	r24, 0x10	; 16
     f28:	93 e0       	ldi	r25, 0x03	; 3
     f2a:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     f2e:	87 e0       	ldi	r24, 0x07	; 7
     f30:	93 e0       	ldi	r25, 0x03	; 3
     f32:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     f36:	8d ef       	ldi	r24, 0xFD	; 253
     f38:	92 e0       	ldi	r25, 0x02	; 2
     f3a:	0e 94 bb 01 	call	0x376	; 0x376 <vListInitialise>
     f3e:	86 e2       	ldi	r24, 0x26	; 38
     f40:	93 e0       	ldi	r25, 0x03	; 3
     f42:	90 93 1c 03 	sts	0x031C, r25	; 0x80031c <pxDelayedTaskList+0x1>
     f46:	80 93 1b 03 	sts	0x031B, r24	; 0x80031b <pxDelayedTaskList>
     f4a:	8d e1       	ldi	r24, 0x1D	; 29
     f4c:	93 e0       	ldi	r25, 0x03	; 3
     f4e:	90 93 1a 03 	sts	0x031A, r25	; 0x80031a <pxOverflowDelayedTaskList+0x1>
     f52:	80 93 19 03 	sts	0x0319, r24	; 0x800319 <pxOverflowDelayedTaskList>
     f56:	10 c0       	rjmp	.+32     	; 0xf78 <xTaskCreate+0x1a4>
     f58:	80 91 f8 02 	lds	r24, 0x02F8	; 0x8002f8 <xSchedulerRunning>
     f5c:	81 11       	cpse	r24, r1
     f5e:	0c c0       	rjmp	.+24     	; 0xf78 <xTaskCreate+0x1a4>
     f60:	e0 91 53 03 	lds	r30, 0x0353	; 0x800353 <pxCurrentTCB>
     f64:	f0 91 54 03 	lds	r31, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     f68:	96 89       	ldd	r25, Z+22	; 0x16
     f6a:	8e 89       	ldd	r24, Y+22	; 0x16
     f6c:	89 17       	cp	r24, r25
     f6e:	20 f0       	brcs	.+8      	; 0xf78 <xTaskCreate+0x1a4>
     f70:	d0 93 54 03 	sts	0x0354, r29	; 0x800354 <pxCurrentTCB+0x1>
     f74:	c0 93 53 03 	sts	0x0353, r28	; 0x800353 <pxCurrentTCB>
     f78:	80 91 f3 02 	lds	r24, 0x02F3	; 0x8002f3 <uxTaskNumber>
     f7c:	8f 5f       	subi	r24, 0xFF	; 255
     f7e:	80 93 f3 02 	sts	0x02F3, r24	; 0x8002f3 <uxTaskNumber>
     f82:	8e 89       	ldd	r24, Y+22	; 0x16
     f84:	90 91 f9 02 	lds	r25, 0x02F9	; 0x8002f9 <uxTopReadyPriority>
     f88:	98 17       	cp	r25, r24
     f8a:	10 f4       	brcc	.+4      	; 0xf90 <xTaskCreate+0x1bc>
     f8c:	80 93 f9 02 	sts	0x02F9, r24	; 0x8002f9 <uxTopReadyPriority>
     f90:	90 e0       	ldi	r25, 0x00	; 0
     f92:	9c 01       	movw	r18, r24
     f94:	22 0f       	add	r18, r18
     f96:	33 1f       	adc	r19, r19
     f98:	22 0f       	add	r18, r18
     f9a:	33 1f       	adc	r19, r19
     f9c:	22 0f       	add	r18, r18
     f9e:	33 1f       	adc	r19, r19
     fa0:	82 0f       	add	r24, r18
     fa2:	93 1f       	adc	r25, r19
     fa4:	b6 01       	movw	r22, r12
     fa6:	81 5d       	subi	r24, 0xD1	; 209
     fa8:	9c 4f       	sbci	r25, 0xFC	; 252
     faa:	0e 94 cd 01 	call	0x39a	; 0x39a <vListInsertEnd>
     fae:	0f 90       	pop	r0
     fb0:	0f be       	out	0x3f, r0	; 63
     fb2:	80 91 f8 02 	lds	r24, 0x02F8	; 0x8002f8 <xSchedulerRunning>
     fb6:	88 23       	and	r24, r24
     fb8:	61 f0       	breq	.+24     	; 0xfd2 <xTaskCreate+0x1fe>
     fba:	e0 91 53 03 	lds	r30, 0x0353	; 0x800353 <pxCurrentTCB>
     fbe:	f0 91 54 03 	lds	r31, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
     fc2:	96 89       	ldd	r25, Z+22	; 0x16
     fc4:	8e 89       	ldd	r24, Y+22	; 0x16
     fc6:	98 17       	cp	r25, r24
     fc8:	30 f4       	brcc	.+12     	; 0xfd6 <xTaskCreate+0x202>
     fca:	0e 94 e7 02 	call	0x5ce	; 0x5ce <vPortYield>
     fce:	81 e0       	ldi	r24, 0x01	; 1
     fd0:	05 c0       	rjmp	.+10     	; 0xfdc <xTaskCreate+0x208>
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	03 c0       	rjmp	.+6      	; 0xfdc <xTaskCreate+0x208>
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	01 c0       	rjmp	.+2      	; 0xfdc <xTaskCreate+0x208>
     fda:	8f ef       	ldi	r24, 0xFF	; 255
     fdc:	df 91       	pop	r29
     fde:	cf 91       	pop	r28
     fe0:	0f 91       	pop	r16
     fe2:	ff 90       	pop	r15
     fe4:	ef 90       	pop	r14
     fe6:	df 90       	pop	r13
     fe8:	cf 90       	pop	r12
     fea:	bf 90       	pop	r11
     fec:	af 90       	pop	r10
     fee:	9f 90       	pop	r9
     ff0:	8f 90       	pop	r8
     ff2:	7f 90       	pop	r7
     ff4:	6f 90       	pop	r6
     ff6:	5f 90       	pop	r5
     ff8:	4f 90       	pop	r4
     ffa:	08 95       	ret

00000ffc <vTaskDelete>:
     ffc:	0f 93       	push	r16
     ffe:	1f 93       	push	r17
    1000:	cf 93       	push	r28
    1002:	df 93       	push	r29
    1004:	ec 01       	movw	r28, r24
    1006:	0f b6       	in	r0, 0x3f	; 63
    1008:	f8 94       	cli
    100a:	0f 92       	push	r0
    100c:	89 2b       	or	r24, r25
    100e:	21 f4       	brne	.+8      	; 0x1018 <vTaskDelete+0x1c>
    1010:	c0 91 53 03 	lds	r28, 0x0353	; 0x800353 <pxCurrentTCB>
    1014:	d0 91 54 03 	lds	r29, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    1018:	8e 01       	movw	r16, r28
    101a:	0e 5f       	subi	r16, 0xFE	; 254
    101c:	1f 4f       	sbci	r17, 0xFF	; 255
    101e:	c8 01       	movw	r24, r16
    1020:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    1024:	8c 89       	ldd	r24, Y+20	; 0x14
    1026:	9d 89       	ldd	r25, Y+21	; 0x15
    1028:	89 2b       	or	r24, r25
    102a:	21 f0       	breq	.+8      	; 0x1034 <vTaskDelete+0x38>
    102c:	ce 01       	movw	r24, r28
    102e:	0c 96       	adiw	r24, 0x0c	; 12
    1030:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    1034:	80 91 f3 02 	lds	r24, 0x02F3	; 0x8002f3 <uxTaskNumber>
    1038:	8f 5f       	subi	r24, 0xFF	; 255
    103a:	80 93 f3 02 	sts	0x02F3, r24	; 0x8002f3 <uxTaskNumber>
    103e:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <pxCurrentTCB>
    1042:	90 91 54 03 	lds	r25, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    1046:	c8 17       	cp	r28, r24
    1048:	d9 07       	cpc	r29, r25
    104a:	59 f4       	brne	.+22     	; 0x1062 <vTaskDelete+0x66>
    104c:	b8 01       	movw	r22, r16
    104e:	87 e0       	ldi	r24, 0x07	; 7
    1050:	93 e0       	ldi	r25, 0x03	; 3
    1052:	0e 94 cd 01 	call	0x39a	; 0x39a <vListInsertEnd>
    1056:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <uxDeletedTasksWaitingCleanUp>
    105a:	8f 5f       	subi	r24, 0xFF	; 255
    105c:	80 93 06 03 	sts	0x0306, r24	; 0x800306 <uxDeletedTasksWaitingCleanUp>
    1060:	0e c0       	rjmp	.+28     	; 0x107e <vTaskDelete+0x82>
    1062:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <uxCurrentNumberOfTasks>
    1066:	81 50       	subi	r24, 0x01	; 1
    1068:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <uxCurrentNumberOfTasks>
    106c:	8f 89       	ldd	r24, Y+23	; 0x17
    106e:	98 8d       	ldd	r25, Y+24	; 0x18
    1070:	0e 94 ba 01 	call	0x374	; 0x374 <vPortFree>
    1074:	ce 01       	movw	r24, r28
    1076:	0e 94 ba 01 	call	0x374	; 0x374 <vPortFree>
    107a:	0e 94 47 06 	call	0xc8e	; 0xc8e <prvResetNextTaskUnblockTime>
    107e:	0f 90       	pop	r0
    1080:	0f be       	out	0x3f, r0	; 63
    1082:	80 91 f8 02 	lds	r24, 0x02F8	; 0x8002f8 <xSchedulerRunning>
    1086:	88 23       	and	r24, r24
    1088:	49 f0       	breq	.+18     	; 0x109c <vTaskDelete+0xa0>
    108a:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <pxCurrentTCB>
    108e:	90 91 54 03 	lds	r25, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    1092:	c8 17       	cp	r28, r24
    1094:	d9 07       	cpc	r29, r25
    1096:	11 f4       	brne	.+4      	; 0x109c <vTaskDelete+0xa0>
    1098:	0e 94 e7 02 	call	0x5ce	; 0x5ce <vPortYield>
    109c:	df 91       	pop	r29
    109e:	cf 91       	pop	r28
    10a0:	1f 91       	pop	r17
    10a2:	0f 91       	pop	r16
    10a4:	08 95       	ret

000010a6 <vTaskStartScheduler>:
    10a6:	ef 92       	push	r14
    10a8:	ff 92       	push	r15
    10aa:	0f 93       	push	r16
    10ac:	0f 2e       	mov	r0, r31
    10ae:	ff ee       	ldi	r31, 0xEF	; 239
    10b0:	ef 2e       	mov	r14, r31
    10b2:	f2 e0       	ldi	r31, 0x02	; 2
    10b4:	ff 2e       	mov	r15, r31
    10b6:	f0 2d       	mov	r31, r0
    10b8:	00 e0       	ldi	r16, 0x00	; 0
    10ba:	20 e0       	ldi	r18, 0x00	; 0
    10bc:	30 e0       	ldi	r19, 0x00	; 0
    10be:	45 e5       	ldi	r20, 0x55	; 85
    10c0:	50 e0       	ldi	r21, 0x00	; 0
    10c2:	6b e8       	ldi	r22, 0x8B	; 139
    10c4:	70 e0       	ldi	r23, 0x00	; 0
    10c6:	86 e6       	ldi	r24, 0x66	; 102
    10c8:	96 e0       	ldi	r25, 0x06	; 6
    10ca:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <xTaskCreate>
    10ce:	81 30       	cpi	r24, 0x01	; 1
    10d0:	81 f4       	brne	.+32     	; 0x10f2 <vTaskStartScheduler+0x4c>
    10d2:	f8 94       	cli
    10d4:	8f ef       	ldi	r24, 0xFF	; 255
    10d6:	9f ef       	ldi	r25, 0xFF	; 255
    10d8:	90 93 f2 02 	sts	0x02F2, r25	; 0x8002f2 <xNextTaskUnblockTime+0x1>
    10dc:	80 93 f1 02 	sts	0x02F1, r24	; 0x8002f1 <xNextTaskUnblockTime>
    10e0:	81 e0       	ldi	r24, 0x01	; 1
    10e2:	80 93 f8 02 	sts	0x02F8, r24	; 0x8002f8 <xSchedulerRunning>
    10e6:	10 92 fb 02 	sts	0x02FB, r1	; 0x8002fb <xTickCount+0x1>
    10ea:	10 92 fa 02 	sts	0x02FA, r1	; 0x8002fa <xTickCount>
    10ee:	0e 94 b2 02 	call	0x564	; 0x564 <xPortStartScheduler>
    10f2:	0f 91       	pop	r16
    10f4:	ff 90       	pop	r15
    10f6:	ef 90       	pop	r14
    10f8:	08 95       	ret

000010fa <vTaskSuspendAll>:
    10fa:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    10fe:	8f 5f       	subi	r24, 0xFF	; 255
    1100:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <uxSchedulerSuspended>
    1104:	08 95       	ret

00001106 <xTaskIncrementTick>:
    1106:	cf 92       	push	r12
    1108:	df 92       	push	r13
    110a:	ef 92       	push	r14
    110c:	ff 92       	push	r15
    110e:	0f 93       	push	r16
    1110:	1f 93       	push	r17
    1112:	cf 93       	push	r28
    1114:	df 93       	push	r29
    1116:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    111a:	81 11       	cpse	r24, r1
    111c:	9f c0       	rjmp	.+318    	; 0x125c <xTaskIncrementTick+0x156>
    111e:	e0 90 fa 02 	lds	r14, 0x02FA	; 0x8002fa <xTickCount>
    1122:	f0 90 fb 02 	lds	r15, 0x02FB	; 0x8002fb <xTickCount+0x1>
    1126:	8f ef       	ldi	r24, 0xFF	; 255
    1128:	e8 1a       	sub	r14, r24
    112a:	f8 0a       	sbc	r15, r24
    112c:	f0 92 fb 02 	sts	0x02FB, r15	; 0x8002fb <xTickCount+0x1>
    1130:	e0 92 fa 02 	sts	0x02FA, r14	; 0x8002fa <xTickCount>
    1134:	e1 14       	cp	r14, r1
    1136:	f1 04       	cpc	r15, r1
    1138:	b9 f4       	brne	.+46     	; 0x1168 <xTaskIncrementTick+0x62>
    113a:	80 91 1b 03 	lds	r24, 0x031B	; 0x80031b <pxDelayedTaskList>
    113e:	90 91 1c 03 	lds	r25, 0x031C	; 0x80031c <pxDelayedTaskList+0x1>
    1142:	20 91 19 03 	lds	r18, 0x0319	; 0x800319 <pxOverflowDelayedTaskList>
    1146:	30 91 1a 03 	lds	r19, 0x031A	; 0x80031a <pxOverflowDelayedTaskList+0x1>
    114a:	30 93 1c 03 	sts	0x031C, r19	; 0x80031c <pxDelayedTaskList+0x1>
    114e:	20 93 1b 03 	sts	0x031B, r18	; 0x80031b <pxDelayedTaskList>
    1152:	90 93 1a 03 	sts	0x031A, r25	; 0x80031a <pxOverflowDelayedTaskList+0x1>
    1156:	80 93 19 03 	sts	0x0319, r24	; 0x800319 <pxOverflowDelayedTaskList>
    115a:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <xNumOfOverflows>
    115e:	8f 5f       	subi	r24, 0xFF	; 255
    1160:	80 93 f4 02 	sts	0x02F4, r24	; 0x8002f4 <xNumOfOverflows>
    1164:	0e 94 47 06 	call	0xc8e	; 0xc8e <prvResetNextTaskUnblockTime>
    1168:	80 91 f1 02 	lds	r24, 0x02F1	; 0x8002f1 <xNextTaskUnblockTime>
    116c:	90 91 f2 02 	lds	r25, 0x02F2	; 0x8002f2 <xNextTaskUnblockTime+0x1>
    1170:	e8 16       	cp	r14, r24
    1172:	f9 06       	cpc	r15, r25
    1174:	10 f4       	brcc	.+4      	; 0x117a <xTaskIncrementTick+0x74>
    1176:	d1 2c       	mov	r13, r1
    1178:	53 c0       	rjmp	.+166    	; 0x1220 <xTaskIncrementTick+0x11a>
    117a:	d1 2c       	mov	r13, r1
    117c:	cc 24       	eor	r12, r12
    117e:	c3 94       	inc	r12
    1180:	e0 91 1b 03 	lds	r30, 0x031B	; 0x80031b <pxDelayedTaskList>
    1184:	f0 91 1c 03 	lds	r31, 0x031C	; 0x80031c <pxDelayedTaskList+0x1>
    1188:	80 81       	ld	r24, Z
    118a:	81 11       	cpse	r24, r1
    118c:	07 c0       	rjmp	.+14     	; 0x119c <xTaskIncrementTick+0x96>
    118e:	8f ef       	ldi	r24, 0xFF	; 255
    1190:	9f ef       	ldi	r25, 0xFF	; 255
    1192:	90 93 f2 02 	sts	0x02F2, r25	; 0x8002f2 <xNextTaskUnblockTime+0x1>
    1196:	80 93 f1 02 	sts	0x02F1, r24	; 0x8002f1 <xNextTaskUnblockTime>
    119a:	42 c0       	rjmp	.+132    	; 0x1220 <xTaskIncrementTick+0x11a>
    119c:	e0 91 1b 03 	lds	r30, 0x031B	; 0x80031b <pxDelayedTaskList>
    11a0:	f0 91 1c 03 	lds	r31, 0x031C	; 0x80031c <pxDelayedTaskList+0x1>
    11a4:	05 80       	ldd	r0, Z+5	; 0x05
    11a6:	f6 81       	ldd	r31, Z+6	; 0x06
    11a8:	e0 2d       	mov	r30, r0
    11aa:	c6 81       	ldd	r28, Z+6	; 0x06
    11ac:	d7 81       	ldd	r29, Z+7	; 0x07
    11ae:	8a 81       	ldd	r24, Y+2	; 0x02
    11b0:	9b 81       	ldd	r25, Y+3	; 0x03
    11b2:	e8 16       	cp	r14, r24
    11b4:	f9 06       	cpc	r15, r25
    11b6:	28 f4       	brcc	.+10     	; 0x11c2 <xTaskIncrementTick+0xbc>
    11b8:	90 93 f2 02 	sts	0x02F2, r25	; 0x8002f2 <xNextTaskUnblockTime+0x1>
    11bc:	80 93 f1 02 	sts	0x02F1, r24	; 0x8002f1 <xNextTaskUnblockTime>
    11c0:	2f c0       	rjmp	.+94     	; 0x1220 <xTaskIncrementTick+0x11a>
    11c2:	8e 01       	movw	r16, r28
    11c4:	0e 5f       	subi	r16, 0xFE	; 254
    11c6:	1f 4f       	sbci	r17, 0xFF	; 255
    11c8:	c8 01       	movw	r24, r16
    11ca:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    11ce:	8c 89       	ldd	r24, Y+20	; 0x14
    11d0:	9d 89       	ldd	r25, Y+21	; 0x15
    11d2:	89 2b       	or	r24, r25
    11d4:	21 f0       	breq	.+8      	; 0x11de <xTaskIncrementTick+0xd8>
    11d6:	ce 01       	movw	r24, r28
    11d8:	0c 96       	adiw	r24, 0x0c	; 12
    11da:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    11de:	8e 89       	ldd	r24, Y+22	; 0x16
    11e0:	90 91 f9 02 	lds	r25, 0x02F9	; 0x8002f9 <uxTopReadyPriority>
    11e4:	98 17       	cp	r25, r24
    11e6:	10 f4       	brcc	.+4      	; 0x11ec <xTaskIncrementTick+0xe6>
    11e8:	80 93 f9 02 	sts	0x02F9, r24	; 0x8002f9 <uxTopReadyPriority>
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	9c 01       	movw	r18, r24
    11f0:	22 0f       	add	r18, r18
    11f2:	33 1f       	adc	r19, r19
    11f4:	22 0f       	add	r18, r18
    11f6:	33 1f       	adc	r19, r19
    11f8:	22 0f       	add	r18, r18
    11fa:	33 1f       	adc	r19, r19
    11fc:	82 0f       	add	r24, r18
    11fe:	93 1f       	adc	r25, r19
    1200:	b8 01       	movw	r22, r16
    1202:	81 5d       	subi	r24, 0xD1	; 209
    1204:	9c 4f       	sbci	r25, 0xFC	; 252
    1206:	0e 94 cd 01 	call	0x39a	; 0x39a <vListInsertEnd>
    120a:	e0 91 53 03 	lds	r30, 0x0353	; 0x800353 <pxCurrentTCB>
    120e:	f0 91 54 03 	lds	r31, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    1212:	9e 89       	ldd	r25, Y+22	; 0x16
    1214:	86 89       	ldd	r24, Z+22	; 0x16
    1216:	98 17       	cp	r25, r24
    1218:	08 f4       	brcc	.+2      	; 0x121c <xTaskIncrementTick+0x116>
    121a:	b2 cf       	rjmp	.-156    	; 0x1180 <xTaskIncrementTick+0x7a>
    121c:	dc 2c       	mov	r13, r12
    121e:	b0 cf       	rjmp	.-160    	; 0x1180 <xTaskIncrementTick+0x7a>
    1220:	e0 91 53 03 	lds	r30, 0x0353	; 0x800353 <pxCurrentTCB>
    1224:	f0 91 54 03 	lds	r31, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    1228:	86 89       	ldd	r24, Z+22	; 0x16
    122a:	90 e0       	ldi	r25, 0x00	; 0
    122c:	fc 01       	movw	r30, r24
    122e:	ee 0f       	add	r30, r30
    1230:	ff 1f       	adc	r31, r31
    1232:	ee 0f       	add	r30, r30
    1234:	ff 1f       	adc	r31, r31
    1236:	ee 0f       	add	r30, r30
    1238:	ff 1f       	adc	r31, r31
    123a:	8e 0f       	add	r24, r30
    123c:	9f 1f       	adc	r25, r31
    123e:	fc 01       	movw	r30, r24
    1240:	e1 5d       	subi	r30, 0xD1	; 209
    1242:	fc 4f       	sbci	r31, 0xFC	; 252
    1244:	80 81       	ld	r24, Z
    1246:	82 30       	cpi	r24, 0x02	; 2
    1248:	10 f0       	brcs	.+4      	; 0x124e <xTaskIncrementTick+0x148>
    124a:	dd 24       	eor	r13, r13
    124c:	d3 94       	inc	r13
    124e:	80 91 f5 02 	lds	r24, 0x02F5	; 0x8002f5 <xYieldPending>
    1252:	88 23       	and	r24, r24
    1254:	69 f0       	breq	.+26     	; 0x1270 <xTaskIncrementTick+0x16a>
    1256:	dd 24       	eor	r13, r13
    1258:	d3 94       	inc	r13
    125a:	0a c0       	rjmp	.+20     	; 0x1270 <xTaskIncrementTick+0x16a>
    125c:	80 91 f6 02 	lds	r24, 0x02F6	; 0x8002f6 <xPendedTicks>
    1260:	90 91 f7 02 	lds	r25, 0x02F7	; 0x8002f7 <xPendedTicks+0x1>
    1264:	01 96       	adiw	r24, 0x01	; 1
    1266:	90 93 f7 02 	sts	0x02F7, r25	; 0x8002f7 <xPendedTicks+0x1>
    126a:	80 93 f6 02 	sts	0x02F6, r24	; 0x8002f6 <xPendedTicks>
    126e:	d1 2c       	mov	r13, r1
    1270:	8d 2d       	mov	r24, r13
    1272:	df 91       	pop	r29
    1274:	cf 91       	pop	r28
    1276:	1f 91       	pop	r17
    1278:	0f 91       	pop	r16
    127a:	ff 90       	pop	r15
    127c:	ef 90       	pop	r14
    127e:	df 90       	pop	r13
    1280:	cf 90       	pop	r12
    1282:	08 95       	ret

00001284 <xTaskResumeAll>:
    1284:	df 92       	push	r13
    1286:	ef 92       	push	r14
    1288:	ff 92       	push	r15
    128a:	0f 93       	push	r16
    128c:	1f 93       	push	r17
    128e:	cf 93       	push	r28
    1290:	df 93       	push	r29
    1292:	0f b6       	in	r0, 0x3f	; 63
    1294:	f8 94       	cli
    1296:	0f 92       	push	r0
    1298:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    129c:	81 50       	subi	r24, 0x01	; 1
    129e:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <uxSchedulerSuspended>
    12a2:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    12a6:	81 11       	cpse	r24, r1
    12a8:	63 c0       	rjmp	.+198    	; 0x1370 <xTaskResumeAll+0xec>
    12aa:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <uxCurrentNumberOfTasks>
    12ae:	81 11       	cpse	r24, r1
    12b0:	33 c0       	rjmp	.+102    	; 0x1318 <xTaskResumeAll+0x94>
    12b2:	61 c0       	rjmp	.+194    	; 0x1376 <xTaskResumeAll+0xf2>
    12b4:	d7 01       	movw	r26, r14
    12b6:	15 96       	adiw	r26, 0x05	; 5
    12b8:	ed 91       	ld	r30, X+
    12ba:	fc 91       	ld	r31, X
    12bc:	16 97       	sbiw	r26, 0x06	; 6
    12be:	c6 81       	ldd	r28, Z+6	; 0x06
    12c0:	d7 81       	ldd	r29, Z+7	; 0x07
    12c2:	ce 01       	movw	r24, r28
    12c4:	0c 96       	adiw	r24, 0x0c	; 12
    12c6:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    12ca:	8e 01       	movw	r16, r28
    12cc:	0e 5f       	subi	r16, 0xFE	; 254
    12ce:	1f 4f       	sbci	r17, 0xFF	; 255
    12d0:	c8 01       	movw	r24, r16
    12d2:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    12d6:	8e 89       	ldd	r24, Y+22	; 0x16
    12d8:	90 91 f9 02 	lds	r25, 0x02F9	; 0x8002f9 <uxTopReadyPriority>
    12dc:	98 17       	cp	r25, r24
    12de:	10 f4       	brcc	.+4      	; 0x12e4 <xTaskResumeAll+0x60>
    12e0:	80 93 f9 02 	sts	0x02F9, r24	; 0x8002f9 <uxTopReadyPriority>
    12e4:	90 e0       	ldi	r25, 0x00	; 0
    12e6:	9c 01       	movw	r18, r24
    12e8:	22 0f       	add	r18, r18
    12ea:	33 1f       	adc	r19, r19
    12ec:	22 0f       	add	r18, r18
    12ee:	33 1f       	adc	r19, r19
    12f0:	22 0f       	add	r18, r18
    12f2:	33 1f       	adc	r19, r19
    12f4:	82 0f       	add	r24, r18
    12f6:	93 1f       	adc	r25, r19
    12f8:	b8 01       	movw	r22, r16
    12fa:	81 5d       	subi	r24, 0xD1	; 209
    12fc:	9c 4f       	sbci	r25, 0xFC	; 252
    12fe:	0e 94 cd 01 	call	0x39a	; 0x39a <vListInsertEnd>
    1302:	e0 91 53 03 	lds	r30, 0x0353	; 0x800353 <pxCurrentTCB>
    1306:	f0 91 54 03 	lds	r31, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    130a:	9e 89       	ldd	r25, Y+22	; 0x16
    130c:	86 89       	ldd	r24, Z+22	; 0x16
    130e:	98 17       	cp	r25, r24
    1310:	68 f0       	brcs	.+26     	; 0x132c <xTaskResumeAll+0xa8>
    1312:	d0 92 f5 02 	sts	0x02F5, r13	; 0x8002f5 <xYieldPending>
    1316:	0a c0       	rjmp	.+20     	; 0x132c <xTaskResumeAll+0xa8>
    1318:	c0 e0       	ldi	r28, 0x00	; 0
    131a:	d0 e0       	ldi	r29, 0x00	; 0
    131c:	0f 2e       	mov	r0, r31
    131e:	f0 e1       	ldi	r31, 0x10	; 16
    1320:	ef 2e       	mov	r14, r31
    1322:	f3 e0       	ldi	r31, 0x03	; 3
    1324:	ff 2e       	mov	r15, r31
    1326:	f0 2d       	mov	r31, r0
    1328:	dd 24       	eor	r13, r13
    132a:	d3 94       	inc	r13
    132c:	f7 01       	movw	r30, r14
    132e:	80 81       	ld	r24, Z
    1330:	81 11       	cpse	r24, r1
    1332:	c0 cf       	rjmp	.-128    	; 0x12b4 <xTaskResumeAll+0x30>
    1334:	cd 2b       	or	r28, r29
    1336:	11 f0       	breq	.+4      	; 0x133c <xTaskResumeAll+0xb8>
    1338:	0e 94 47 06 	call	0xc8e	; 0xc8e <prvResetNextTaskUnblockTime>
    133c:	c0 91 f6 02 	lds	r28, 0x02F6	; 0x8002f6 <xPendedTicks>
    1340:	d0 91 f7 02 	lds	r29, 0x02F7	; 0x8002f7 <xPendedTicks+0x1>
    1344:	20 97       	sbiw	r28, 0x00	; 0
    1346:	61 f0       	breq	.+24     	; 0x1360 <xTaskResumeAll+0xdc>
    1348:	11 e0       	ldi	r17, 0x01	; 1
    134a:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskIncrementTick>
    134e:	81 11       	cpse	r24, r1
    1350:	10 93 f5 02 	sts	0x02F5, r17	; 0x8002f5 <xYieldPending>
    1354:	21 97       	sbiw	r28, 0x01	; 1
    1356:	c9 f7       	brne	.-14     	; 0x134a <xTaskResumeAll+0xc6>
    1358:	10 92 f7 02 	sts	0x02F7, r1	; 0x8002f7 <xPendedTicks+0x1>
    135c:	10 92 f6 02 	sts	0x02F6, r1	; 0x8002f6 <xPendedTicks>
    1360:	80 91 f5 02 	lds	r24, 0x02F5	; 0x8002f5 <xYieldPending>
    1364:	88 23       	and	r24, r24
    1366:	31 f0       	breq	.+12     	; 0x1374 <xTaskResumeAll+0xf0>
    1368:	0e 94 e7 02 	call	0x5ce	; 0x5ce <vPortYield>
    136c:	81 e0       	ldi	r24, 0x01	; 1
    136e:	03 c0       	rjmp	.+6      	; 0x1376 <xTaskResumeAll+0xf2>
    1370:	80 e0       	ldi	r24, 0x00	; 0
    1372:	01 c0       	rjmp	.+2      	; 0x1376 <xTaskResumeAll+0xf2>
    1374:	80 e0       	ldi	r24, 0x00	; 0
    1376:	0f 90       	pop	r0
    1378:	0f be       	out	0x3f, r0	; 63
    137a:	df 91       	pop	r29
    137c:	cf 91       	pop	r28
    137e:	1f 91       	pop	r17
    1380:	0f 91       	pop	r16
    1382:	ff 90       	pop	r15
    1384:	ef 90       	pop	r14
    1386:	df 90       	pop	r13
    1388:	08 95       	ret

0000138a <vTaskDelay>:
    138a:	cf 93       	push	r28
    138c:	df 93       	push	r29
    138e:	ec 01       	movw	r28, r24
    1390:	89 2b       	or	r24, r25
    1392:	51 f0       	breq	.+20     	; 0x13a8 <vTaskDelay+0x1e>
    1394:	0e 94 7d 08 	call	0x10fa	; 0x10fa <vTaskSuspendAll>
    1398:	60 e0       	ldi	r22, 0x00	; 0
    139a:	ce 01       	movw	r24, r28
    139c:	0e 94 92 06 	call	0xd24	; 0xd24 <prvAddCurrentTaskToDelayedList>
    13a0:	0e 94 42 09 	call	0x1284	; 0x1284 <xTaskResumeAll>
    13a4:	81 11       	cpse	r24, r1
    13a6:	02 c0       	rjmp	.+4      	; 0x13ac <vTaskDelay+0x22>
    13a8:	0e 94 e7 02 	call	0x5ce	; 0x5ce <vPortYield>
    13ac:	df 91       	pop	r29
    13ae:	cf 91       	pop	r28
    13b0:	08 95       	ret

000013b2 <vTaskSwitchContext>:
    13b2:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    13b6:	88 23       	and	r24, r24
    13b8:	21 f0       	breq	.+8      	; 0x13c2 <vTaskSwitchContext+0x10>
    13ba:	81 e0       	ldi	r24, 0x01	; 1
    13bc:	80 93 f5 02 	sts	0x02F5, r24	; 0x8002f5 <xYieldPending>
    13c0:	08 95       	ret
    13c2:	10 92 f5 02 	sts	0x02F5, r1	; 0x8002f5 <xYieldPending>
    13c6:	20 91 f9 02 	lds	r18, 0x02F9	; 0x8002f9 <uxTopReadyPriority>
    13ca:	82 2f       	mov	r24, r18
    13cc:	90 e0       	ldi	r25, 0x00	; 0
    13ce:	fc 01       	movw	r30, r24
    13d0:	ee 0f       	add	r30, r30
    13d2:	ff 1f       	adc	r31, r31
    13d4:	ee 0f       	add	r30, r30
    13d6:	ff 1f       	adc	r31, r31
    13d8:	ee 0f       	add	r30, r30
    13da:	ff 1f       	adc	r31, r31
    13dc:	e8 0f       	add	r30, r24
    13de:	f9 1f       	adc	r31, r25
    13e0:	e1 5d       	subi	r30, 0xD1	; 209
    13e2:	fc 4f       	sbci	r31, 0xFC	; 252
    13e4:	30 81       	ld	r19, Z
    13e6:	31 11       	cpse	r19, r1
    13e8:	11 c0       	rjmp	.+34     	; 0x140c <vTaskSwitchContext+0x5a>
    13ea:	21 50       	subi	r18, 0x01	; 1
    13ec:	82 2f       	mov	r24, r18
    13ee:	90 e0       	ldi	r25, 0x00	; 0
    13f0:	fc 01       	movw	r30, r24
    13f2:	ee 0f       	add	r30, r30
    13f4:	ff 1f       	adc	r31, r31
    13f6:	ee 0f       	add	r30, r30
    13f8:	ff 1f       	adc	r31, r31
    13fa:	ee 0f       	add	r30, r30
    13fc:	ff 1f       	adc	r31, r31
    13fe:	e8 0f       	add	r30, r24
    1400:	f9 1f       	adc	r31, r25
    1402:	e1 5d       	subi	r30, 0xD1	; 209
    1404:	fc 4f       	sbci	r31, 0xFC	; 252
    1406:	30 81       	ld	r19, Z
    1408:	33 23       	and	r19, r19
    140a:	79 f3       	breq	.-34     	; 0x13ea <vTaskSwitchContext+0x38>
    140c:	ac 01       	movw	r20, r24
    140e:	44 0f       	add	r20, r20
    1410:	55 1f       	adc	r21, r21
    1412:	44 0f       	add	r20, r20
    1414:	55 1f       	adc	r21, r21
    1416:	44 0f       	add	r20, r20
    1418:	55 1f       	adc	r21, r21
    141a:	48 0f       	add	r20, r24
    141c:	59 1f       	adc	r21, r25
    141e:	da 01       	movw	r26, r20
    1420:	a1 5d       	subi	r26, 0xD1	; 209
    1422:	bc 4f       	sbci	r27, 0xFC	; 252
    1424:	11 96       	adiw	r26, 0x01	; 1
    1426:	ed 91       	ld	r30, X+
    1428:	fc 91       	ld	r31, X
    142a:	12 97       	sbiw	r26, 0x02	; 2
    142c:	02 80       	ldd	r0, Z+2	; 0x02
    142e:	f3 81       	ldd	r31, Z+3	; 0x03
    1430:	e0 2d       	mov	r30, r0
    1432:	12 96       	adiw	r26, 0x02	; 2
    1434:	fc 93       	st	X, r31
    1436:	ee 93       	st	-X, r30
    1438:	11 97       	sbiw	r26, 0x01	; 1
    143a:	4e 5c       	subi	r20, 0xCE	; 206
    143c:	5c 4f       	sbci	r21, 0xFC	; 252
    143e:	e4 17       	cp	r30, r20
    1440:	f5 07       	cpc	r31, r21
    1442:	29 f4       	brne	.+10     	; 0x144e <vTaskSwitchContext+0x9c>
    1444:	42 81       	ldd	r20, Z+2	; 0x02
    1446:	53 81       	ldd	r21, Z+3	; 0x03
    1448:	fd 01       	movw	r30, r26
    144a:	52 83       	std	Z+2, r21	; 0x02
    144c:	41 83       	std	Z+1, r20	; 0x01
    144e:	fc 01       	movw	r30, r24
    1450:	ee 0f       	add	r30, r30
    1452:	ff 1f       	adc	r31, r31
    1454:	ee 0f       	add	r30, r30
    1456:	ff 1f       	adc	r31, r31
    1458:	ee 0f       	add	r30, r30
    145a:	ff 1f       	adc	r31, r31
    145c:	8e 0f       	add	r24, r30
    145e:	9f 1f       	adc	r25, r31
    1460:	fc 01       	movw	r30, r24
    1462:	e1 5d       	subi	r30, 0xD1	; 209
    1464:	fc 4f       	sbci	r31, 0xFC	; 252
    1466:	01 80       	ldd	r0, Z+1	; 0x01
    1468:	f2 81       	ldd	r31, Z+2	; 0x02
    146a:	e0 2d       	mov	r30, r0
    146c:	86 81       	ldd	r24, Z+6	; 0x06
    146e:	97 81       	ldd	r25, Z+7	; 0x07
    1470:	90 93 54 03 	sts	0x0354, r25	; 0x800354 <pxCurrentTCB+0x1>
    1474:	80 93 53 03 	sts	0x0353, r24	; 0x800353 <pxCurrentTCB>
    1478:	20 93 f9 02 	sts	0x02F9, r18	; 0x8002f9 <uxTopReadyPriority>
    147c:	08 95       	ret

0000147e <vTaskPlaceOnEventList>:
    147e:	cf 93       	push	r28
    1480:	df 93       	push	r29
    1482:	eb 01       	movw	r28, r22
    1484:	60 91 53 03 	lds	r22, 0x0353	; 0x800353 <pxCurrentTCB>
    1488:	70 91 54 03 	lds	r23, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    148c:	64 5f       	subi	r22, 0xF4	; 244
    148e:	7f 4f       	sbci	r23, 0xFF	; 255
    1490:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vListInsert>
    1494:	61 e0       	ldi	r22, 0x01	; 1
    1496:	ce 01       	movw	r24, r28
    1498:	0e 94 92 06 	call	0xd24	; 0xd24 <prvAddCurrentTaskToDelayedList>
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	08 95       	ret

000014a2 <xTaskRemoveFromEventList>:
    14a2:	0f 93       	push	r16
    14a4:	1f 93       	push	r17
    14a6:	cf 93       	push	r28
    14a8:	df 93       	push	r29
    14aa:	dc 01       	movw	r26, r24
    14ac:	15 96       	adiw	r26, 0x05	; 5
    14ae:	ed 91       	ld	r30, X+
    14b0:	fc 91       	ld	r31, X
    14b2:	16 97       	sbiw	r26, 0x06	; 6
    14b4:	c6 81       	ldd	r28, Z+6	; 0x06
    14b6:	d7 81       	ldd	r29, Z+7	; 0x07
    14b8:	8e 01       	movw	r16, r28
    14ba:	04 5f       	subi	r16, 0xF4	; 244
    14bc:	1f 4f       	sbci	r17, 0xFF	; 255
    14be:	c8 01       	movw	r24, r16
    14c0:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    14c4:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxSchedulerSuspended>
    14c8:	81 11       	cpse	r24, r1
    14ca:	1c c0       	rjmp	.+56     	; 0x1504 <xTaskRemoveFromEventList+0x62>
    14cc:	0a 50       	subi	r16, 0x0A	; 10
    14ce:	11 09       	sbc	r17, r1
    14d0:	c8 01       	movw	r24, r16
    14d2:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    14d6:	8e 89       	ldd	r24, Y+22	; 0x16
    14d8:	90 91 f9 02 	lds	r25, 0x02F9	; 0x8002f9 <uxTopReadyPriority>
    14dc:	98 17       	cp	r25, r24
    14de:	10 f4       	brcc	.+4      	; 0x14e4 <xTaskRemoveFromEventList+0x42>
    14e0:	80 93 f9 02 	sts	0x02F9, r24	; 0x8002f9 <uxTopReadyPriority>
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	9c 01       	movw	r18, r24
    14e8:	22 0f       	add	r18, r18
    14ea:	33 1f       	adc	r19, r19
    14ec:	22 0f       	add	r18, r18
    14ee:	33 1f       	adc	r19, r19
    14f0:	22 0f       	add	r18, r18
    14f2:	33 1f       	adc	r19, r19
    14f4:	82 0f       	add	r24, r18
    14f6:	93 1f       	adc	r25, r19
    14f8:	b8 01       	movw	r22, r16
    14fa:	81 5d       	subi	r24, 0xD1	; 209
    14fc:	9c 4f       	sbci	r25, 0xFC	; 252
    14fe:	0e 94 cd 01 	call	0x39a	; 0x39a <vListInsertEnd>
    1502:	05 c0       	rjmp	.+10     	; 0x150e <xTaskRemoveFromEventList+0x6c>
    1504:	b8 01       	movw	r22, r16
    1506:	80 e1       	ldi	r24, 0x10	; 16
    1508:	93 e0       	ldi	r25, 0x03	; 3
    150a:	0e 94 cd 01 	call	0x39a	; 0x39a <vListInsertEnd>
    150e:	e0 91 53 03 	lds	r30, 0x0353	; 0x800353 <pxCurrentTCB>
    1512:	f0 91 54 03 	lds	r31, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    1516:	9e 89       	ldd	r25, Y+22	; 0x16
    1518:	86 89       	ldd	r24, Z+22	; 0x16
    151a:	89 17       	cp	r24, r25
    151c:	20 f4       	brcc	.+8      	; 0x1526 <xTaskRemoveFromEventList+0x84>
    151e:	81 e0       	ldi	r24, 0x01	; 1
    1520:	80 93 f5 02 	sts	0x02F5, r24	; 0x8002f5 <xYieldPending>
    1524:	01 c0       	rjmp	.+2      	; 0x1528 <xTaskRemoveFromEventList+0x86>
    1526:	80 e0       	ldi	r24, 0x00	; 0
    1528:	df 91       	pop	r29
    152a:	cf 91       	pop	r28
    152c:	1f 91       	pop	r17
    152e:	0f 91       	pop	r16
    1530:	08 95       	ret

00001532 <vTaskInternalSetTimeOutState>:
    1532:	20 91 f4 02 	lds	r18, 0x02F4	; 0x8002f4 <xNumOfOverflows>
    1536:	fc 01       	movw	r30, r24
    1538:	20 83       	st	Z, r18
    153a:	20 91 fa 02 	lds	r18, 0x02FA	; 0x8002fa <xTickCount>
    153e:	30 91 fb 02 	lds	r19, 0x02FB	; 0x8002fb <xTickCount+0x1>
    1542:	32 83       	std	Z+2, r19	; 0x02
    1544:	21 83       	std	Z+1, r18	; 0x01
    1546:	08 95       	ret

00001548 <xTaskCheckForTimeOut>:
    1548:	cf 93       	push	r28
    154a:	df 93       	push	r29
    154c:	0f b6       	in	r0, 0x3f	; 63
    154e:	f8 94       	cli
    1550:	0f 92       	push	r0
    1552:	20 91 fa 02 	lds	r18, 0x02FA	; 0x8002fa <xTickCount>
    1556:	30 91 fb 02 	lds	r19, 0x02FB	; 0x8002fb <xTickCount+0x1>
    155a:	db 01       	movw	r26, r22
    155c:	4d 91       	ld	r20, X+
    155e:	5c 91       	ld	r21, X
    1560:	4f 3f       	cpi	r20, 0xFF	; 255
    1562:	bf ef       	ldi	r27, 0xFF	; 255
    1564:	5b 07       	cpc	r21, r27
    1566:	f1 f0       	breq	.+60     	; 0x15a4 <xTaskCheckForTimeOut+0x5c>
    1568:	ec 01       	movw	r28, r24
    156a:	e9 81       	ldd	r30, Y+1	; 0x01
    156c:	fa 81       	ldd	r31, Y+2	; 0x02
    156e:	a0 91 f4 02 	lds	r26, 0x02F4	; 0x8002f4 <xNumOfOverflows>
    1572:	b8 81       	ld	r27, Y
    1574:	ba 17       	cp	r27, r26
    1576:	19 f0       	breq	.+6      	; 0x157e <xTaskCheckForTimeOut+0x36>
    1578:	2e 17       	cp	r18, r30
    157a:	3f 07       	cpc	r19, r31
    157c:	a8 f4       	brcc	.+42     	; 0x15a8 <xTaskCheckForTimeOut+0x60>
    157e:	2e 1b       	sub	r18, r30
    1580:	3f 0b       	sbc	r19, r31
    1582:	24 17       	cp	r18, r20
    1584:	35 07       	cpc	r19, r21
    1586:	48 f4       	brcc	.+18     	; 0x159a <xTaskCheckForTimeOut+0x52>
    1588:	fb 01       	movw	r30, r22
    158a:	42 1b       	sub	r20, r18
    158c:	53 0b       	sbc	r21, r19
    158e:	51 83       	std	Z+1, r21	; 0x01
    1590:	40 83       	st	Z, r20
    1592:	0e 94 99 0a 	call	0x1532	; 0x1532 <vTaskInternalSetTimeOutState>
    1596:	80 e0       	ldi	r24, 0x00	; 0
    1598:	08 c0       	rjmp	.+16     	; 0x15aa <xTaskCheckForTimeOut+0x62>
    159a:	fb 01       	movw	r30, r22
    159c:	11 82       	std	Z+1, r1	; 0x01
    159e:	10 82       	st	Z, r1
    15a0:	81 e0       	ldi	r24, 0x01	; 1
    15a2:	03 c0       	rjmp	.+6      	; 0x15aa <xTaskCheckForTimeOut+0x62>
    15a4:	80 e0       	ldi	r24, 0x00	; 0
    15a6:	01 c0       	rjmp	.+2      	; 0x15aa <xTaskCheckForTimeOut+0x62>
    15a8:	81 e0       	ldi	r24, 0x01	; 1
    15aa:	0f 90       	pop	r0
    15ac:	0f be       	out	0x3f, r0	; 63
    15ae:	df 91       	pop	r29
    15b0:	cf 91       	pop	r28
    15b2:	08 95       	ret

000015b4 <vTaskMissedYield>:
    15b4:	81 e0       	ldi	r24, 0x01	; 1
    15b6:	80 93 f5 02 	sts	0x02F5, r24	; 0x8002f5 <xYieldPending>
    15ba:	08 95       	ret

000015bc <xTaskPriorityInherit>:
    15bc:	0f 93       	push	r16
    15be:	1f 93       	push	r17
    15c0:	cf 93       	push	r28
    15c2:	df 93       	push	r29
    15c4:	fc 01       	movw	r30, r24
    15c6:	89 2b       	or	r24, r25
    15c8:	09 f4       	brne	.+2      	; 0x15cc <xTaskPriorityInherit+0x10>
    15ca:	64 c0       	rjmp	.+200    	; 0x1694 <xTaskPriorityInherit+0xd8>
    15cc:	26 89       	ldd	r18, Z+22	; 0x16
    15ce:	a0 91 53 03 	lds	r26, 0x0353	; 0x800353 <pxCurrentTCB>
    15d2:	b0 91 54 03 	lds	r27, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    15d6:	56 96       	adiw	r26, 0x16	; 22
    15d8:	8c 91       	ld	r24, X
    15da:	28 17       	cp	r18, r24
    15dc:	08 f0       	brcs	.+2      	; 0x15e0 <xTaskPriorityInherit+0x24>
    15de:	4e c0       	rjmp	.+156    	; 0x167c <xTaskPriorityInherit+0xc0>
    15e0:	84 85       	ldd	r24, Z+12	; 0x0c
    15e2:	95 85       	ldd	r25, Z+13	; 0x0d
    15e4:	99 23       	and	r25, r25
    15e6:	64 f0       	brlt	.+24     	; 0x1600 <xTaskPriorityInherit+0x44>
    15e8:	a0 91 53 03 	lds	r26, 0x0353	; 0x800353 <pxCurrentTCB>
    15ec:	b0 91 54 03 	lds	r27, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    15f0:	56 96       	adiw	r26, 0x16	; 22
    15f2:	3c 91       	ld	r19, X
    15f4:	84 e0       	ldi	r24, 0x04	; 4
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	83 1b       	sub	r24, r19
    15fa:	91 09       	sbc	r25, r1
    15fc:	95 87       	std	Z+13, r25	; 0x0d
    15fe:	84 87       	std	Z+12, r24	; 0x0c
    1600:	30 e0       	ldi	r19, 0x00	; 0
    1602:	c9 01       	movw	r24, r18
    1604:	88 0f       	add	r24, r24
    1606:	99 1f       	adc	r25, r25
    1608:	88 0f       	add	r24, r24
    160a:	99 1f       	adc	r25, r25
    160c:	88 0f       	add	r24, r24
    160e:	99 1f       	adc	r25, r25
    1610:	28 0f       	add	r18, r24
    1612:	39 1f       	adc	r19, r25
    1614:	21 5d       	subi	r18, 0xD1	; 209
    1616:	3c 4f       	sbci	r19, 0xFC	; 252
    1618:	82 85       	ldd	r24, Z+10	; 0x0a
    161a:	93 85       	ldd	r25, Z+11	; 0x0b
    161c:	82 17       	cp	r24, r18
    161e:	93 07       	cpc	r25, r19
    1620:	21 f5       	brne	.+72     	; 0x166a <xTaskPriorityInherit+0xae>
    1622:	8f 01       	movw	r16, r30
    1624:	ef 01       	movw	r28, r30
    1626:	22 96       	adiw	r28, 0x02	; 2
    1628:	ce 01       	movw	r24, r28
    162a:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    162e:	e0 91 53 03 	lds	r30, 0x0353	; 0x800353 <pxCurrentTCB>
    1632:	f0 91 54 03 	lds	r31, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    1636:	86 89       	ldd	r24, Z+22	; 0x16
    1638:	f8 01       	movw	r30, r16
    163a:	86 8b       	std	Z+22, r24	; 0x16
    163c:	90 91 f9 02 	lds	r25, 0x02F9	; 0x8002f9 <uxTopReadyPriority>
    1640:	98 17       	cp	r25, r24
    1642:	10 f4       	brcc	.+4      	; 0x1648 <xTaskPriorityInherit+0x8c>
    1644:	80 93 f9 02 	sts	0x02F9, r24	; 0x8002f9 <uxTopReadyPriority>
    1648:	90 e0       	ldi	r25, 0x00	; 0
    164a:	9c 01       	movw	r18, r24
    164c:	22 0f       	add	r18, r18
    164e:	33 1f       	adc	r19, r19
    1650:	22 0f       	add	r18, r18
    1652:	33 1f       	adc	r19, r19
    1654:	22 0f       	add	r18, r18
    1656:	33 1f       	adc	r19, r19
    1658:	82 0f       	add	r24, r18
    165a:	93 1f       	adc	r25, r19
    165c:	be 01       	movw	r22, r28
    165e:	81 5d       	subi	r24, 0xD1	; 209
    1660:	9c 4f       	sbci	r25, 0xFC	; 252
    1662:	0e 94 cd 01 	call	0x39a	; 0x39a <vListInsertEnd>
    1666:	81 e0       	ldi	r24, 0x01	; 1
    1668:	16 c0       	rjmp	.+44     	; 0x1696 <xTaskPriorityInherit+0xda>
    166a:	a0 91 53 03 	lds	r26, 0x0353	; 0x800353 <pxCurrentTCB>
    166e:	b0 91 54 03 	lds	r27, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    1672:	56 96       	adiw	r26, 0x16	; 22
    1674:	8c 91       	ld	r24, X
    1676:	86 8b       	std	Z+22, r24	; 0x16
    1678:	81 e0       	ldi	r24, 0x01	; 1
    167a:	0d c0       	rjmp	.+26     	; 0x1696 <xTaskPriorityInherit+0xda>
    167c:	a0 91 53 03 	lds	r26, 0x0353	; 0x800353 <pxCurrentTCB>
    1680:	b0 91 54 03 	lds	r27, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    1684:	81 e0       	ldi	r24, 0x01	; 1
    1686:	21 a1       	ldd	r18, Z+33	; 0x21
    1688:	56 96       	adiw	r26, 0x16	; 22
    168a:	9c 91       	ld	r25, X
    168c:	29 17       	cp	r18, r25
    168e:	18 f0       	brcs	.+6      	; 0x1696 <xTaskPriorityInherit+0xda>
    1690:	80 e0       	ldi	r24, 0x00	; 0
    1692:	01 c0       	rjmp	.+2      	; 0x1696 <xTaskPriorityInherit+0xda>
    1694:	80 e0       	ldi	r24, 0x00	; 0
    1696:	df 91       	pop	r29
    1698:	cf 91       	pop	r28
    169a:	1f 91       	pop	r17
    169c:	0f 91       	pop	r16
    169e:	08 95       	ret

000016a0 <xTaskPriorityDisinherit>:
    16a0:	0f 93       	push	r16
    16a2:	1f 93       	push	r17
    16a4:	cf 93       	push	r28
    16a6:	df 93       	push	r29
    16a8:	fc 01       	movw	r30, r24
    16aa:	89 2b       	or	r24, r25
    16ac:	79 f1       	breq	.+94     	; 0x170c <xTaskPriorityDisinherit+0x6c>
    16ae:	82 a1       	ldd	r24, Z+34	; 0x22
    16b0:	81 50       	subi	r24, 0x01	; 1
    16b2:	82 a3       	std	Z+34, r24	; 0x22
    16b4:	26 89       	ldd	r18, Z+22	; 0x16
    16b6:	91 a1       	ldd	r25, Z+33	; 0x21
    16b8:	29 17       	cp	r18, r25
    16ba:	51 f1       	breq	.+84     	; 0x1710 <xTaskPriorityDisinherit+0x70>
    16bc:	81 11       	cpse	r24, r1
    16be:	2a c0       	rjmp	.+84     	; 0x1714 <xTaskPriorityDisinherit+0x74>
    16c0:	ef 01       	movw	r28, r30
    16c2:	8f 01       	movw	r16, r30
    16c4:	0e 5f       	subi	r16, 0xFE	; 254
    16c6:	1f 4f       	sbci	r17, 0xFF	; 255
    16c8:	c8 01       	movw	r24, r16
    16ca:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    16ce:	89 a1       	ldd	r24, Y+33	; 0x21
    16d0:	8e 8b       	std	Y+22, r24	; 0x16
    16d2:	24 e0       	ldi	r18, 0x04	; 4
    16d4:	30 e0       	ldi	r19, 0x00	; 0
    16d6:	28 1b       	sub	r18, r24
    16d8:	31 09       	sbc	r19, r1
    16da:	3d 87       	std	Y+13, r19	; 0x0d
    16dc:	2c 87       	std	Y+12, r18	; 0x0c
    16de:	90 91 f9 02 	lds	r25, 0x02F9	; 0x8002f9 <uxTopReadyPriority>
    16e2:	98 17       	cp	r25, r24
    16e4:	10 f4       	brcc	.+4      	; 0x16ea <xTaskPriorityDisinherit+0x4a>
    16e6:	80 93 f9 02 	sts	0x02F9, r24	; 0x8002f9 <uxTopReadyPriority>
    16ea:	90 e0       	ldi	r25, 0x00	; 0
    16ec:	9c 01       	movw	r18, r24
    16ee:	22 0f       	add	r18, r18
    16f0:	33 1f       	adc	r19, r19
    16f2:	22 0f       	add	r18, r18
    16f4:	33 1f       	adc	r19, r19
    16f6:	22 0f       	add	r18, r18
    16f8:	33 1f       	adc	r19, r19
    16fa:	82 0f       	add	r24, r18
    16fc:	93 1f       	adc	r25, r19
    16fe:	b8 01       	movw	r22, r16
    1700:	81 5d       	subi	r24, 0xD1	; 209
    1702:	9c 4f       	sbci	r25, 0xFC	; 252
    1704:	0e 94 cd 01 	call	0x39a	; 0x39a <vListInsertEnd>
    1708:	81 e0       	ldi	r24, 0x01	; 1
    170a:	05 c0       	rjmp	.+10     	; 0x1716 <xTaskPriorityDisinherit+0x76>
    170c:	80 e0       	ldi	r24, 0x00	; 0
    170e:	03 c0       	rjmp	.+6      	; 0x1716 <xTaskPriorityDisinherit+0x76>
    1710:	80 e0       	ldi	r24, 0x00	; 0
    1712:	01 c0       	rjmp	.+2      	; 0x1716 <xTaskPriorityDisinherit+0x76>
    1714:	80 e0       	ldi	r24, 0x00	; 0
    1716:	df 91       	pop	r29
    1718:	cf 91       	pop	r28
    171a:	1f 91       	pop	r17
    171c:	0f 91       	pop	r16
    171e:	08 95       	ret

00001720 <vTaskPriorityDisinheritAfterTimeout>:
    1720:	0f 93       	push	r16
    1722:	1f 93       	push	r17
    1724:	cf 93       	push	r28
    1726:	df 93       	push	r29
    1728:	fc 01       	movw	r30, r24
    172a:	89 2b       	or	r24, r25
    172c:	09 f4       	brne	.+2      	; 0x1730 <vTaskPriorityDisinheritAfterTimeout+0x10>
    172e:	43 c0       	rjmp	.+134    	; 0x17b6 <vTaskPriorityDisinheritAfterTimeout+0x96>
    1730:	91 a1       	ldd	r25, Z+33	; 0x21
    1732:	96 17       	cp	r25, r22
    1734:	08 f4       	brcc	.+2      	; 0x1738 <vTaskPriorityDisinheritAfterTimeout+0x18>
    1736:	96 2f       	mov	r25, r22
    1738:	86 89       	ldd	r24, Z+22	; 0x16
    173a:	89 17       	cp	r24, r25
    173c:	e1 f1       	breq	.+120    	; 0x17b6 <vTaskPriorityDisinheritAfterTimeout+0x96>
    173e:	22 a1       	ldd	r18, Z+34	; 0x22
    1740:	21 30       	cpi	r18, 0x01	; 1
    1742:	c9 f5       	brne	.+114    	; 0x17b6 <vTaskPriorityDisinheritAfterTimeout+0x96>
    1744:	96 8b       	std	Z+22, r25	; 0x16
    1746:	24 85       	ldd	r18, Z+12	; 0x0c
    1748:	35 85       	ldd	r19, Z+13	; 0x0d
    174a:	33 23       	and	r19, r19
    174c:	34 f0       	brlt	.+12     	; 0x175a <vTaskPriorityDisinheritAfterTimeout+0x3a>
    174e:	24 e0       	ldi	r18, 0x04	; 4
    1750:	30 e0       	ldi	r19, 0x00	; 0
    1752:	29 1b       	sub	r18, r25
    1754:	31 09       	sbc	r19, r1
    1756:	35 87       	std	Z+13, r19	; 0x0d
    1758:	24 87       	std	Z+12, r18	; 0x0c
    175a:	90 e0       	ldi	r25, 0x00	; 0
    175c:	9c 01       	movw	r18, r24
    175e:	22 0f       	add	r18, r18
    1760:	33 1f       	adc	r19, r19
    1762:	22 0f       	add	r18, r18
    1764:	33 1f       	adc	r19, r19
    1766:	22 0f       	add	r18, r18
    1768:	33 1f       	adc	r19, r19
    176a:	82 0f       	add	r24, r18
    176c:	93 1f       	adc	r25, r19
    176e:	81 5d       	subi	r24, 0xD1	; 209
    1770:	9c 4f       	sbci	r25, 0xFC	; 252
    1772:	22 85       	ldd	r18, Z+10	; 0x0a
    1774:	33 85       	ldd	r19, Z+11	; 0x0b
    1776:	28 17       	cp	r18, r24
    1778:	39 07       	cpc	r19, r25
    177a:	e9 f4       	brne	.+58     	; 0x17b6 <vTaskPriorityDisinheritAfterTimeout+0x96>
    177c:	ef 01       	movw	r28, r30
    177e:	8f 01       	movw	r16, r30
    1780:	0e 5f       	subi	r16, 0xFE	; 254
    1782:	1f 4f       	sbci	r17, 0xFF	; 255
    1784:	c8 01       	movw	r24, r16
    1786:	0e 94 1f 02 	call	0x43e	; 0x43e <uxListRemove>
    178a:	8e 89       	ldd	r24, Y+22	; 0x16
    178c:	90 91 f9 02 	lds	r25, 0x02F9	; 0x8002f9 <uxTopReadyPriority>
    1790:	98 17       	cp	r25, r24
    1792:	10 f4       	brcc	.+4      	; 0x1798 <vTaskPriorityDisinheritAfterTimeout+0x78>
    1794:	80 93 f9 02 	sts	0x02F9, r24	; 0x8002f9 <uxTopReadyPriority>
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	9c 01       	movw	r18, r24
    179c:	22 0f       	add	r18, r18
    179e:	33 1f       	adc	r19, r19
    17a0:	22 0f       	add	r18, r18
    17a2:	33 1f       	adc	r19, r19
    17a4:	22 0f       	add	r18, r18
    17a6:	33 1f       	adc	r19, r19
    17a8:	82 0f       	add	r24, r18
    17aa:	93 1f       	adc	r25, r19
    17ac:	b8 01       	movw	r22, r16
    17ae:	81 5d       	subi	r24, 0xD1	; 209
    17b0:	9c 4f       	sbci	r25, 0xFC	; 252
    17b2:	0e 94 cd 01 	call	0x39a	; 0x39a <vListInsertEnd>
    17b6:	df 91       	pop	r29
    17b8:	cf 91       	pop	r28
    17ba:	1f 91       	pop	r17
    17bc:	0f 91       	pop	r16
    17be:	08 95       	ret

000017c0 <pvTaskIncrementMutexHeldCount>:

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    17c0:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <pxCurrentTCB>
    17c4:	90 91 54 03 	lds	r25, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    17c8:	89 2b       	or	r24, r25
    17ca:	39 f0       	breq	.+14     	; 0x17da <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    17cc:	e0 91 53 03 	lds	r30, 0x0353	; 0x800353 <pxCurrentTCB>
    17d0:	f0 91 54 03 	lds	r31, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
    17d4:	82 a1       	ldd	r24, Z+34	; 0x22
    17d6:	8f 5f       	subi	r24, 0xFF	; 255
    17d8:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    17da:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <pxCurrentTCB>
    17de:	90 91 54 03 	lds	r25, 0x0354	; 0x800354 <pxCurrentTCB+0x1>
	}
    17e2:	08 95       	ret

000017e4 <memcpy>:
    17e4:	fb 01       	movw	r30, r22
    17e6:	dc 01       	movw	r26, r24
    17e8:	02 c0       	rjmp	.+4      	; 0x17ee <memcpy+0xa>
    17ea:	01 90       	ld	r0, Z+
    17ec:	0d 92       	st	X+, r0
    17ee:	41 50       	subi	r20, 0x01	; 1
    17f0:	50 40       	sbci	r21, 0x00	; 0
    17f2:	d8 f7       	brcc	.-10     	; 0x17ea <memcpy+0x6>
    17f4:	08 95       	ret

000017f6 <_exit>:
    17f6:	f8 94       	cli

000017f8 <__stop_program>:
    17f8:	ff cf       	rjmp	.-2      	; 0x17f8 <__stop_program>
