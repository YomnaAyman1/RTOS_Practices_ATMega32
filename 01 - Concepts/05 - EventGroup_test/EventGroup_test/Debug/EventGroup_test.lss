
EventGroup_test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000fb0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  00000fb0  00001044  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002c5  00800066  00800066  0000104a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000104a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000107c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002a8  00000000  00000000  000010b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000034f8  00000000  00000000  00001360  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e6e  00000000  00000000  00004858  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001c24  00000000  00000000  000056c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007fc  00000000  00000000  000072ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000011c4  00000000  00000000  00007ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000030bb  00000000  00000000  00008cac  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002d8  00000000  00000000  0000bd67  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 be 03 	jmp	0x77c	; 0x77c <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 eb       	ldi	r30, 0xB0	; 176
  68:	ff e0       	ldi	r31, 0x0F	; 15
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a6 36       	cpi	r26, 0x66	; 102
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	23 e0       	ldi	r18, 0x03	; 3
  78:	a6 e6       	ldi	r26, 0x66	; 102
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ab 32       	cpi	r26, 0x2B	; 43
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 45 02 	call	0x48a	; 0x48a <main>
  8a:	0c 94 d6 07 	jmp	0xfac	; 0xfac <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xEventGroupCreate>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
  92:	cf 93       	push	r28
  94:	df 93       	push	r29
  96:	8b e0       	ldi	r24, 0x0B	; 11
  98:	90 e0       	ldi	r25, 0x00	; 0
  9a:	0e 94 52 01 	call	0x2a4	; 0x2a4 <pvPortMalloc>
  9e:	ec 01       	movw	r28, r24
  a0:	00 97       	sbiw	r24, 0x00	; 0
  a2:	31 f0       	breq	.+12     	; 0xb0 <xEventGroupCreate+0x1e>
  a4:	fc 01       	movw	r30, r24
  a6:	11 92       	st	Z+, r1
  a8:	11 92       	st	Z+, r1
  aa:	cf 01       	movw	r24, r30
  ac:	0e 94 88 01 	call	0x310	; 0x310 <vListInitialise>
  b0:	ce 01       	movw	r24, r28
  b2:	df 91       	pop	r29
  b4:	cf 91       	pop	r28
  b6:	08 95       	ret

000000b8 <xEventGroupWaitBits>:
  b8:	af 92       	push	r10
  ba:	bf 92       	push	r11
  bc:	cf 92       	push	r12
  be:	df 92       	push	r13
  c0:	ef 92       	push	r14
  c2:	ff 92       	push	r15
  c4:	0f 93       	push	r16
  c6:	1f 93       	push	r17
  c8:	cf 93       	push	r28
  ca:	df 93       	push	r29
  cc:	7c 01       	movw	r14, r24
  ce:	6b 01       	movw	r12, r22
  d0:	a4 2e       	mov	r10, r20
  d2:	b2 2e       	mov	r11, r18
  d4:	0e 94 ac 05 	call	0xb58	; 0xb58 <vTaskSuspendAll>
  d8:	f7 01       	movw	r30, r14
  da:	c0 81       	ld	r28, Z
  dc:	d1 81       	ldd	r29, Z+1	; 0x01
  de:	b1 10       	cpse	r11, r1
  e0:	08 c0       	rjmp	.+16     	; 0xf2 <xEventGroupWaitBits+0x3a>
  e2:	81 e0       	ldi	r24, 0x01	; 1
  e4:	9e 01       	movw	r18, r28
  e6:	2c 21       	and	r18, r12
  e8:	3d 21       	and	r19, r13
  ea:	23 2b       	or	r18, r19
  ec:	51 f4       	brne	.+20     	; 0x102 <xEventGroupWaitBits+0x4a>
  ee:	80 e0       	ldi	r24, 0x00	; 0
  f0:	08 c0       	rjmp	.+16     	; 0x102 <xEventGroupWaitBits+0x4a>
  f2:	81 e0       	ldi	r24, 0x01	; 1
  f4:	9e 01       	movw	r18, r28
  f6:	2c 21       	and	r18, r12
  f8:	3d 21       	and	r19, r13
  fa:	2c 15       	cp	r18, r12
  fc:	3d 05       	cpc	r19, r13
  fe:	09 f0       	breq	.+2      	; 0x102 <xEventGroupWaitBits+0x4a>
 100:	80 e0       	ldi	r24, 0x00	; 0
 102:	88 23       	and	r24, r24
 104:	61 f0       	breq	.+24     	; 0x11e <xEventGroupWaitBits+0x66>
 106:	aa 20       	and	r10, r10
 108:	09 f4       	brne	.+2      	; 0x10c <xEventGroupWaitBits+0x54>
 10a:	50 c0       	rjmp	.+160    	; 0x1ac <xEventGroupWaitBits+0xf4>
 10c:	b6 01       	movw	r22, r12
 10e:	60 95       	com	r22
 110:	70 95       	com	r23
 112:	6c 23       	and	r22, r28
 114:	7d 23       	and	r23, r29
 116:	f7 01       	movw	r30, r14
 118:	71 83       	std	Z+1, r23	; 0x01
 11a:	60 83       	st	Z, r22
 11c:	47 c0       	rjmp	.+142    	; 0x1ac <xEventGroupWaitBits+0xf4>
 11e:	01 15       	cp	r16, r1
 120:	11 05       	cpc	r17, r1
 122:	09 f4       	brne	.+2      	; 0x126 <xEventGroupWaitBits+0x6e>
 124:	43 c0       	rjmp	.+134    	; 0x1ac <xEventGroupWaitBits+0xf4>
 126:	aa 20       	and	r10, r10
 128:	19 f0       	breq	.+6      	; 0x130 <xEventGroupWaitBits+0x78>
 12a:	60 e0       	ldi	r22, 0x00	; 0
 12c:	71 e0       	ldi	r23, 0x01	; 1
 12e:	02 c0       	rjmp	.+4      	; 0x134 <xEventGroupWaitBits+0x7c>
 130:	60 e0       	ldi	r22, 0x00	; 0
 132:	70 e0       	ldi	r23, 0x00	; 0
 134:	b1 10       	cpse	r11, r1
 136:	74 60       	ori	r23, 0x04	; 4
 138:	6c 29       	or	r22, r12
 13a:	7d 29       	or	r23, r13
 13c:	a8 01       	movw	r20, r16
 13e:	c7 01       	movw	r24, r14
 140:	02 96       	adiw	r24, 0x02	; 2
 142:	0e 94 6e 07 	call	0xedc	; 0xedc <vTaskPlaceOnUnorderedEventList>
 146:	0e 94 71 06 	call	0xce2	; 0xce2 <xTaskResumeAll>
 14a:	81 11       	cpse	r24, r1
 14c:	02 c0       	rjmp	.+4      	; 0x152 <xEventGroupWaitBits+0x9a>
 14e:	0e 94 09 03 	call	0x612	; 0x612 <vPortYield>
 152:	0e 94 bf 07 	call	0xf7e	; 0xf7e <uxTaskResetEventItemValue>
 156:	91 fd       	sbrc	r25, 1
 158:	26 c0       	rjmp	.+76     	; 0x1a6 <xEventGroupWaitBits+0xee>
 15a:	0f b6       	in	r0, 0x3f	; 63
 15c:	f8 94       	cli
 15e:	0f 92       	push	r0
 160:	f7 01       	movw	r30, r14
 162:	80 81       	ld	r24, Z
 164:	91 81       	ldd	r25, Z+1	; 0x01
 166:	b1 10       	cpse	r11, r1
 168:	08 c0       	rjmp	.+16     	; 0x17a <xEventGroupWaitBits+0xc2>
 16a:	21 e0       	ldi	r18, 0x01	; 1
 16c:	a6 01       	movw	r20, r12
 16e:	48 23       	and	r20, r24
 170:	59 23       	and	r21, r25
 172:	45 2b       	or	r20, r21
 174:	51 f4       	brne	.+20     	; 0x18a <xEventGroupWaitBits+0xd2>
 176:	20 e0       	ldi	r18, 0x00	; 0
 178:	08 c0       	rjmp	.+16     	; 0x18a <xEventGroupWaitBits+0xd2>
 17a:	21 e0       	ldi	r18, 0x01	; 1
 17c:	a6 01       	movw	r20, r12
 17e:	48 23       	and	r20, r24
 180:	59 23       	and	r21, r25
 182:	4c 15       	cp	r20, r12
 184:	5d 05       	cpc	r21, r13
 186:	09 f0       	breq	.+2      	; 0x18a <xEventGroupWaitBits+0xd2>
 188:	20 e0       	ldi	r18, 0x00	; 0
 18a:	22 23       	and	r18, r18
 18c:	51 f0       	breq	.+20     	; 0x1a2 <xEventGroupWaitBits+0xea>
 18e:	aa 20       	and	r10, r10
 190:	41 f0       	breq	.+16     	; 0x1a2 <xEventGroupWaitBits+0xea>
 192:	b6 01       	movw	r22, r12
 194:	60 95       	com	r22
 196:	70 95       	com	r23
 198:	68 23       	and	r22, r24
 19a:	79 23       	and	r23, r25
 19c:	f7 01       	movw	r30, r14
 19e:	71 83       	std	Z+1, r23	; 0x01
 1a0:	60 83       	st	Z, r22
 1a2:	0f 90       	pop	r0
 1a4:	0f be       	out	0x3f, r0	; 63
 1a6:	ec 01       	movw	r28, r24
 1a8:	dd 27       	eor	r29, r29
 1aa:	02 c0       	rjmp	.+4      	; 0x1b0 <xEventGroupWaitBits+0xf8>
 1ac:	0e 94 71 06 	call	0xce2	; 0xce2 <xTaskResumeAll>
 1b0:	ce 01       	movw	r24, r28
 1b2:	df 91       	pop	r29
 1b4:	cf 91       	pop	r28
 1b6:	1f 91       	pop	r17
 1b8:	0f 91       	pop	r16
 1ba:	ff 90       	pop	r15
 1bc:	ef 90       	pop	r14
 1be:	df 90       	pop	r13
 1c0:	cf 90       	pop	r12
 1c2:	bf 90       	pop	r11
 1c4:	af 90       	pop	r10
 1c6:	08 95       	ret

000001c8 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
 1c8:	af 92       	push	r10
 1ca:	bf 92       	push	r11
 1cc:	cf 92       	push	r12
 1ce:	df 92       	push	r13
 1d0:	ef 92       	push	r14
 1d2:	ff 92       	push	r15
 1d4:	0f 93       	push	r16
 1d6:	1f 93       	push	r17
 1d8:	cf 93       	push	r28
 1da:	df 93       	push	r29
 1dc:	7c 01       	movw	r14, r24
 1de:	8b 01       	movw	r16, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1e0:	ec 01       	movw	r28, r24
 1e2:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
 1e4:	0e 94 ac 05 	call	0xb58	; 0xb58 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
 1e8:	d7 01       	movw	r26, r14
 1ea:	17 96       	adiw	r26, 0x07	; 7
 1ec:	ed 91       	ld	r30, X+
 1ee:	fc 91       	ld	r31, X
 1f0:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
 1f2:	8d 91       	ld	r24, X+
 1f4:	9c 91       	ld	r25, X
 1f6:	11 97       	sbiw	r26, 0x01	; 1
 1f8:	08 2b       	or	r16, r24
 1fa:	19 2b       	or	r17, r25
 1fc:	0d 93       	st	X+, r16
 1fe:	1c 93       	st	X, r17

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
 200:	ce 17       	cp	r28, r30
 202:	df 07       	cpc	r29, r31
 204:	a1 f1       	breq	.+104    	; 0x26e <xEventGroupSetBits+0xa6>
 206:	00 e0       	ldi	r16, 0x00	; 0
 208:	10 e0       	ldi	r17, 0x00	; 0
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
 20a:	bb 24       	eor	r11, r11
 20c:	b3 94       	inc	r11
 20e:	a1 2c       	mov	r10, r1
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
 210:	c2 80       	ldd	r12, Z+2	; 0x02
 212:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 214:	80 81       	ld	r24, Z
 216:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 218:	9c 01       	movw	r18, r24
 21a:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 21c:	92 fd       	sbrc	r25, 2
 21e:	0a c0       	rjmp	.+20     	; 0x234 <xEventGroupSetBits+0x6c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
 220:	d7 01       	movw	r26, r14
 222:	6d 91       	ld	r22, X+
 224:	7c 91       	ld	r23, X
 226:	62 23       	and	r22, r18
 228:	73 23       	and	r23, r19
 22a:	4b 2d       	mov	r20, r11
 22c:	67 2b       	or	r22, r23
 22e:	61 f4       	brne	.+24     	; 0x248 <xEventGroupSetBits+0x80>
 230:	4a 2d       	mov	r20, r10
 232:	0a c0       	rjmp	.+20     	; 0x248 <xEventGroupSetBits+0x80>
 234:	d7 01       	movw	r26, r14
 236:	6d 91       	ld	r22, X+
 238:	7c 91       	ld	r23, X
 23a:	62 23       	and	r22, r18
 23c:	73 23       	and	r23, r19
 23e:	4b 2d       	mov	r20, r11
 240:	62 17       	cp	r22, r18
 242:	73 07       	cpc	r23, r19
 244:	09 f0       	breq	.+2      	; 0x248 <xEventGroupSetBits+0x80>
 246:	4a 2d       	mov	r20, r10
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
 248:	44 23       	and	r20, r20
 24a:	59 f0       	breq	.+22     	; 0x262 <xEventGroupSetBits+0x9a>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 24c:	90 ff       	sbrs	r25, 0
 24e:	02 c0       	rjmp	.+4      	; 0x254 <xEventGroupSetBits+0x8c>
				{
					uxBitsToClear |= uxBitsWaitedFor;
 250:	02 2b       	or	r16, r18
 252:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 254:	d7 01       	movw	r26, r14
 256:	6d 91       	ld	r22, X+
 258:	7c 91       	ld	r23, X
 25a:	72 60       	ori	r23, 0x02	; 2
 25c:	cf 01       	movw	r24, r30
 25e:	0e 94 87 07 	call	0xf0e	; 0xf0e <vTaskRemoveFromUnorderedEventList>
 262:	ec 2d       	mov	r30, r12
 264:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
 266:	ce 17       	cp	r28, r30
 268:	df 07       	cpc	r29, r31
 26a:	91 f6       	brne	.-92     	; 0x210 <xEventGroupSetBits+0x48>
 26c:	02 c0       	rjmp	.+4      	; 0x272 <xEventGroupSetBits+0xaa>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 26e:	00 e0       	ldi	r16, 0x00	; 0
 270:	10 e0       	ldi	r17, 0x00	; 0
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 272:	00 95       	com	r16
 274:	10 95       	com	r17
 276:	f7 01       	movw	r30, r14
 278:	80 81       	ld	r24, Z
 27a:	91 81       	ldd	r25, Z+1	; 0x01
 27c:	08 23       	and	r16, r24
 27e:	19 23       	and	r17, r25
 280:	11 83       	std	Z+1, r17	; 0x01
 282:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
 284:	0e 94 71 06 	call	0xce2	; 0xce2 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
 288:	d7 01       	movw	r26, r14
 28a:	8d 91       	ld	r24, X+
 28c:	9c 91       	ld	r25, X
 28e:	df 91       	pop	r29
 290:	cf 91       	pop	r28
 292:	1f 91       	pop	r17
 294:	0f 91       	pop	r16
 296:	ff 90       	pop	r15
 298:	ef 90       	pop	r14
 29a:	df 90       	pop	r13
 29c:	cf 90       	pop	r12
 29e:	bf 90       	pop	r11
 2a0:	af 90       	pop	r10
 2a2:	08 95       	ret

000002a4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 2a4:	cf 93       	push	r28
 2a6:	df 93       	push	r29
 2a8:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
 2aa:	0e 94 ac 05 	call	0xb58	; 0xb58 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 2ae:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <__data_end>
 2b2:	90 91 67 00 	lds	r25, 0x0067	; 0x800067 <__data_end+0x1>
 2b6:	89 2b       	or	r24, r25
 2b8:	31 f4       	brne	.+12     	; 0x2c6 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 2ba:	8b e6       	ldi	r24, 0x6B	; 107
 2bc:	90 e0       	ldi	r25, 0x00	; 0
 2be:	90 93 67 00 	sts	0x0067, r25	; 0x800067 <__data_end+0x1>
 2c2:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 2c6:	20 91 68 00 	lds	r18, 0x0068	; 0x800068 <xNextFreeByte>
 2ca:	30 91 69 00 	lds	r19, 0x0069	; 0x800069 <xNextFreeByte+0x1>
 2ce:	c9 01       	movw	r24, r18
 2d0:	8c 0f       	add	r24, r28
 2d2:	9d 1f       	adc	r25, r29
 2d4:	87 35       	cpi	r24, 0x57	; 87
 2d6:	42 e0       	ldi	r20, 0x02	; 2
 2d8:	94 07       	cpc	r25, r20
 2da:	70 f4       	brcc	.+28     	; 0x2f8 <pvPortMalloc+0x54>
 2dc:	28 17       	cp	r18, r24
 2de:	39 07       	cpc	r19, r25
 2e0:	70 f4       	brcc	.+28     	; 0x2fe <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 2e2:	c0 91 66 00 	lds	r28, 0x0066	; 0x800066 <__data_end>
 2e6:	d0 91 67 00 	lds	r29, 0x0067	; 0x800067 <__data_end+0x1>
 2ea:	c2 0f       	add	r28, r18
 2ec:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 2ee:	90 93 69 00 	sts	0x0069, r25	; 0x800069 <xNextFreeByte+0x1>
 2f2:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <xNextFreeByte>
 2f6:	05 c0       	rjmp	.+10     	; 0x302 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 2f8:	c0 e0       	ldi	r28, 0x00	; 0
 2fa:	d0 e0       	ldi	r29, 0x00	; 0
 2fc:	02 c0       	rjmp	.+4      	; 0x302 <pvPortMalloc+0x5e>
 2fe:	c0 e0       	ldi	r28, 0x00	; 0
 300:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 302:	0e 94 71 06 	call	0xce2	; 0xce2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 306:	ce 01       	movw	r24, r28
 308:	df 91       	pop	r29
 30a:	cf 91       	pop	r28
 30c:	08 95       	ret

0000030e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 30e:	08 95       	ret

00000310 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 310:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 312:	03 96       	adiw	r24, 0x03	; 3
 314:	92 83       	std	Z+2, r25	; 0x02
 316:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 318:	2f ef       	ldi	r18, 0xFF	; 255
 31a:	3f ef       	ldi	r19, 0xFF	; 255
 31c:	34 83       	std	Z+4, r19	; 0x04
 31e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 320:	96 83       	std	Z+6, r25	; 0x06
 322:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 324:	90 87       	std	Z+8, r25	; 0x08
 326:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 328:	10 82       	st	Z, r1
 32a:	08 95       	ret

0000032c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 32c:	fc 01       	movw	r30, r24
 32e:	11 86       	std	Z+9, r1	; 0x09
 330:	10 86       	std	Z+8, r1	; 0x08
 332:	08 95       	ret

00000334 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 334:	cf 93       	push	r28
 336:	df 93       	push	r29
 338:	9c 01       	movw	r18, r24
 33a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 33c:	dc 01       	movw	r26, r24
 33e:	11 96       	adiw	r26, 0x01	; 1
 340:	cd 91       	ld	r28, X+
 342:	dc 91       	ld	r29, X
 344:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 346:	d3 83       	std	Z+3, r29	; 0x03
 348:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 34a:	8c 81       	ldd	r24, Y+4	; 0x04
 34c:	9d 81       	ldd	r25, Y+5	; 0x05
 34e:	95 83       	std	Z+5, r25	; 0x05
 350:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 352:	8c 81       	ldd	r24, Y+4	; 0x04
 354:	9d 81       	ldd	r25, Y+5	; 0x05
 356:	dc 01       	movw	r26, r24
 358:	13 96       	adiw	r26, 0x03	; 3
 35a:	7c 93       	st	X, r23
 35c:	6e 93       	st	-X, r22
 35e:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 360:	7d 83       	std	Y+5, r23	; 0x05
 362:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 364:	31 87       	std	Z+9, r19	; 0x09
 366:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 368:	f9 01       	movw	r30, r18
 36a:	80 81       	ld	r24, Z
 36c:	8f 5f       	subi	r24, 0xFF	; 255
 36e:	80 83       	st	Z, r24
}
 370:	df 91       	pop	r29
 372:	cf 91       	pop	r28
 374:	08 95       	ret

00000376 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 376:	cf 93       	push	r28
 378:	df 93       	push	r29
 37a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 37c:	48 81       	ld	r20, Y
 37e:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 380:	4f 3f       	cpi	r20, 0xFF	; 255
 382:	2f ef       	ldi	r18, 0xFF	; 255
 384:	52 07       	cpc	r21, r18
 386:	21 f4       	brne	.+8      	; 0x390 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 388:	fc 01       	movw	r30, r24
 38a:	a7 81       	ldd	r26, Z+7	; 0x07
 38c:	b0 85       	ldd	r27, Z+8	; 0x08
 38e:	0d c0       	rjmp	.+26     	; 0x3aa <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 390:	dc 01       	movw	r26, r24
 392:	13 96       	adiw	r26, 0x03	; 3
 394:	01 c0       	rjmp	.+2      	; 0x398 <vListInsert+0x22>
 396:	df 01       	movw	r26, r30
 398:	12 96       	adiw	r26, 0x02	; 2
 39a:	ed 91       	ld	r30, X+
 39c:	fc 91       	ld	r31, X
 39e:	13 97       	sbiw	r26, 0x03	; 3
 3a0:	20 81       	ld	r18, Z
 3a2:	31 81       	ldd	r19, Z+1	; 0x01
 3a4:	42 17       	cp	r20, r18
 3a6:	53 07       	cpc	r21, r19
 3a8:	b0 f7       	brcc	.-20     	; 0x396 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 3aa:	12 96       	adiw	r26, 0x02	; 2
 3ac:	ed 91       	ld	r30, X+
 3ae:	fc 91       	ld	r31, X
 3b0:	13 97       	sbiw	r26, 0x03	; 3
 3b2:	fb 83       	std	Y+3, r31	; 0x03
 3b4:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 3b6:	d5 83       	std	Z+5, r29	; 0x05
 3b8:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 3ba:	bd 83       	std	Y+5, r27	; 0x05
 3bc:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 3be:	13 96       	adiw	r26, 0x03	; 3
 3c0:	dc 93       	st	X, r29
 3c2:	ce 93       	st	-X, r28
 3c4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 3c6:	99 87       	std	Y+9, r25	; 0x09
 3c8:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 3ca:	fc 01       	movw	r30, r24
 3cc:	20 81       	ld	r18, Z
 3ce:	2f 5f       	subi	r18, 0xFF	; 255
 3d0:	20 83       	st	Z, r18
}
 3d2:	df 91       	pop	r29
 3d4:	cf 91       	pop	r28
 3d6:	08 95       	ret

000003d8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 3d8:	cf 93       	push	r28
 3da:	df 93       	push	r29
 3dc:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 3de:	a0 85       	ldd	r26, Z+8	; 0x08
 3e0:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 3e2:	c2 81       	ldd	r28, Z+2	; 0x02
 3e4:	d3 81       	ldd	r29, Z+3	; 0x03
 3e6:	84 81       	ldd	r24, Z+4	; 0x04
 3e8:	95 81       	ldd	r25, Z+5	; 0x05
 3ea:	9d 83       	std	Y+5, r25	; 0x05
 3ec:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 3ee:	c4 81       	ldd	r28, Z+4	; 0x04
 3f0:	d5 81       	ldd	r29, Z+5	; 0x05
 3f2:	82 81       	ldd	r24, Z+2	; 0x02
 3f4:	93 81       	ldd	r25, Z+3	; 0x03
 3f6:	9b 83       	std	Y+3, r25	; 0x03
 3f8:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 3fa:	11 96       	adiw	r26, 0x01	; 1
 3fc:	8d 91       	ld	r24, X+
 3fe:	9c 91       	ld	r25, X
 400:	12 97       	sbiw	r26, 0x02	; 2
 402:	e8 17       	cp	r30, r24
 404:	f9 07       	cpc	r31, r25
 406:	31 f4       	brne	.+12     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 408:	84 81       	ldd	r24, Z+4	; 0x04
 40a:	95 81       	ldd	r25, Z+5	; 0x05
 40c:	12 96       	adiw	r26, 0x02	; 2
 40e:	9c 93       	st	X, r25
 410:	8e 93       	st	-X, r24
 412:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 414:	11 86       	std	Z+9, r1	; 0x09
 416:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 418:	8c 91       	ld	r24, X
 41a:	81 50       	subi	r24, 0x01	; 1
 41c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
 41e:	8c 91       	ld	r24, X
}
 420:	df 91       	pop	r29
 422:	cf 91       	pop	r28
 424:	08 95       	ret

00000426 <taskEventTrig>:
#define SECOND_BIT_CHECK (1 << 1)
EventGroupHandle_t event0 ;

void taskEventTrig( void *p ){
	while(1){
		xEventGroupSetBits (event0 ,FIRST_BIT_CHECK );
 426:	61 e0       	ldi	r22, 0x01	; 1
 428:	70 e0       	ldi	r23, 0x00	; 0
 42a:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <event0>
 42e:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <event0+0x1>
 432:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <xEventGroupSetBits>
		vTaskDelay(200);
 436:	88 ec       	ldi	r24, 0xC8	; 200
 438:	90 e0       	ldi	r25, 0x00	; 0
 43a:	0e 94 f4 06 	call	0xde8	; 0xde8 <vTaskDelay>
		xEventGroupSetBits(event0 , SECOND_BIT_CHECK);
 43e:	62 e0       	ldi	r22, 0x02	; 2
 440:	70 e0       	ldi	r23, 0x00	; 0
 442:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <event0>
 446:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <event0+0x1>
 44a:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <xEventGroupSetBits>
		vTaskDelay(200);
 44e:	88 ec       	ldi	r24, 0xC8	; 200
 450:	90 e0       	ldi	r25, 0x00	; 0
 452:	0e 94 f4 06 	call	0xde8	; 0xde8 <vTaskDelay>
 456:	e7 cf       	rjmp	.-50     	; 0x426 <taskEventTrig>

00000458 <checkEvent>:
		xEventGroupValue = xEventGroupWaitBits(event0 , xBitsToWaitFor ,pdTRUE ,pdFALSE,portMAX_DELAY );
		if (xEventGroupValue & FIRST_BIT_CHECK){
			PORTD ^= (1 << 0);
		}
	    if (xEventGroupValue & SECOND_BIT_CHECK){
			PORTD ^= (1 << 1);
 458:	c2 e0       	ldi	r28, 0x02	; 2

void checkEvent( void *p ){
	EventBits_t xEventGroupValue;
	const EventBits_t xBitsToWaitFor = (FIRST_BIT_CHECK | SECOND_BIT_CHECK);
	while(1){
		xEventGroupValue = xEventGroupWaitBits(event0 , xBitsToWaitFor ,pdTRUE ,pdFALSE,portMAX_DELAY );
 45a:	0f ef       	ldi	r16, 0xFF	; 255
 45c:	1f ef       	ldi	r17, 0xFF	; 255
 45e:	20 e0       	ldi	r18, 0x00	; 0
 460:	41 e0       	ldi	r20, 0x01	; 1
 462:	63 e0       	ldi	r22, 0x03	; 3
 464:	70 e0       	ldi	r23, 0x00	; 0
 466:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <event0>
 46a:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <event0+0x1>
 46e:	0e 94 5c 00 	call	0xb8	; 0xb8 <xEventGroupWaitBits>
		if (xEventGroupValue & FIRST_BIT_CHECK){
 472:	80 ff       	sbrs	r24, 0
 474:	04 c0       	rjmp	.+8      	; 0x47e <checkEvent+0x26>
			PORTD ^= (1 << 0);
 476:	22 b3       	in	r18, 0x12	; 18
 478:	91 e0       	ldi	r25, 0x01	; 1
 47a:	92 27       	eor	r25, r18
 47c:	92 bb       	out	0x12, r25	; 18
		}
	    if (xEventGroupValue & SECOND_BIT_CHECK){
 47e:	81 ff       	sbrs	r24, 1
 480:	ec cf       	rjmp	.-40     	; 0x45a <checkEvent+0x2>
			PORTD ^= (1 << 1);
 482:	82 b3       	in	r24, 0x12	; 18
 484:	8c 27       	eor	r24, r28
 486:	82 bb       	out	0x12, r24	; 18
 488:	e8 cf       	rjmp	.-48     	; 0x45a <checkEvent+0x2>

0000048a <main>:
	}
}

int main(void)
{
	DDRD = 3 ;
 48a:	83 e0       	ldi	r24, 0x03	; 3
 48c:	81 bb       	out	0x11, r24	; 17
	event0 = xEventGroupCreate();
 48e:	0e 94 49 00 	call	0x92	; 0x92 <xEventGroupCreate>
 492:	90 93 2a 03 	sts	0x032A, r25	; 0x80032a <event0+0x1>
 496:	80 93 29 03 	sts	0x0329, r24	; 0x800329 <event0>
	xTaskCreate(taskEventTrig , NULL , 80 , NULL , 1 , NULL);
 49a:	e1 2c       	mov	r14, r1
 49c:	f1 2c       	mov	r15, r1
 49e:	01 e0       	ldi	r16, 0x01	; 1
 4a0:	20 e0       	ldi	r18, 0x00	; 0
 4a2:	30 e0       	ldi	r19, 0x00	; 0
 4a4:	40 e5       	ldi	r20, 0x50	; 80
 4a6:	50 e0       	ldi	r21, 0x00	; 0
 4a8:	60 e0       	ldi	r22, 0x00	; 0
 4aa:	70 e0       	ldi	r23, 0x00	; 0
 4ac:	83 e1       	ldi	r24, 0x13	; 19
 4ae:	92 e0       	ldi	r25, 0x02	; 2
 4b0:	0e 94 70 04 	call	0x8e0	; 0x8e0 <xTaskCreate>
	xTaskCreate(checkEvent , NULL , 80 , NULL , 2 , NULL);
 4b4:	02 e0       	ldi	r16, 0x02	; 2
 4b6:	20 e0       	ldi	r18, 0x00	; 0
 4b8:	30 e0       	ldi	r19, 0x00	; 0
 4ba:	40 e5       	ldi	r20, 0x50	; 80
 4bc:	50 e0       	ldi	r21, 0x00	; 0
 4be:	60 e0       	ldi	r22, 0x00	; 0
 4c0:	70 e0       	ldi	r23, 0x00	; 0
 4c2:	8c e2       	ldi	r24, 0x2C	; 44
 4c4:	92 e0       	ldi	r25, 0x02	; 2
 4c6:	0e 94 70 04 	call	0x8e0	; 0x8e0 <xTaskCreate>
	vTaskStartScheduler();
 4ca:	0e 94 82 05 	call	0xb04	; 0xb04 <vTaskStartScheduler>
 4ce:	ff cf       	rjmp	.-2      	; 0x4ce <main+0x44>

000004d0 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 4d0:	31 e1       	ldi	r19, 0x11	; 17
 4d2:	fc 01       	movw	r30, r24
 4d4:	30 83       	st	Z, r19
 4d6:	31 97       	sbiw	r30, 0x01	; 1
 4d8:	22 e2       	ldi	r18, 0x22	; 34
 4da:	20 83       	st	Z, r18
 4dc:	31 97       	sbiw	r30, 0x01	; 1
 4de:	a3 e3       	ldi	r26, 0x33	; 51
 4e0:	a0 83       	st	Z, r26
 4e2:	31 97       	sbiw	r30, 0x01	; 1
 4e4:	60 83       	st	Z, r22
 4e6:	31 97       	sbiw	r30, 0x01	; 1
 4e8:	70 83       	st	Z, r23
 4ea:	31 97       	sbiw	r30, 0x01	; 1
 4ec:	10 82       	st	Z, r1
 4ee:	31 97       	sbiw	r30, 0x01	; 1
 4f0:	60 e8       	ldi	r22, 0x80	; 128
 4f2:	60 83       	st	Z, r22
 4f4:	31 97       	sbiw	r30, 0x01	; 1
 4f6:	10 82       	st	Z, r1
 4f8:	31 97       	sbiw	r30, 0x01	; 1
 4fa:	62 e0       	ldi	r22, 0x02	; 2
 4fc:	60 83       	st	Z, r22
 4fe:	31 97       	sbiw	r30, 0x01	; 1
 500:	63 e0       	ldi	r22, 0x03	; 3
 502:	60 83       	st	Z, r22
 504:	31 97       	sbiw	r30, 0x01	; 1
 506:	64 e0       	ldi	r22, 0x04	; 4
 508:	60 83       	st	Z, r22
 50a:	31 97       	sbiw	r30, 0x01	; 1
 50c:	65 e0       	ldi	r22, 0x05	; 5
 50e:	60 83       	st	Z, r22
 510:	31 97       	sbiw	r30, 0x01	; 1
 512:	66 e0       	ldi	r22, 0x06	; 6
 514:	60 83       	st	Z, r22
 516:	31 97       	sbiw	r30, 0x01	; 1
 518:	67 e0       	ldi	r22, 0x07	; 7
 51a:	60 83       	st	Z, r22
 51c:	31 97       	sbiw	r30, 0x01	; 1
 51e:	68 e0       	ldi	r22, 0x08	; 8
 520:	60 83       	st	Z, r22
 522:	31 97       	sbiw	r30, 0x01	; 1
 524:	69 e0       	ldi	r22, 0x09	; 9
 526:	60 83       	st	Z, r22
 528:	31 97       	sbiw	r30, 0x01	; 1
 52a:	60 e1       	ldi	r22, 0x10	; 16
 52c:	60 83       	st	Z, r22
 52e:	31 97       	sbiw	r30, 0x01	; 1
 530:	30 83       	st	Z, r19
 532:	31 97       	sbiw	r30, 0x01	; 1
 534:	32 e1       	ldi	r19, 0x12	; 18
 536:	30 83       	st	Z, r19
 538:	31 97       	sbiw	r30, 0x01	; 1
 53a:	33 e1       	ldi	r19, 0x13	; 19
 53c:	30 83       	st	Z, r19
 53e:	31 97       	sbiw	r30, 0x01	; 1
 540:	34 e1       	ldi	r19, 0x14	; 20
 542:	30 83       	st	Z, r19
 544:	31 97       	sbiw	r30, 0x01	; 1
 546:	35 e1       	ldi	r19, 0x15	; 21
 548:	30 83       	st	Z, r19
 54a:	31 97       	sbiw	r30, 0x01	; 1
 54c:	36 e1       	ldi	r19, 0x16	; 22
 54e:	30 83       	st	Z, r19
 550:	31 97       	sbiw	r30, 0x01	; 1
 552:	37 e1       	ldi	r19, 0x17	; 23
 554:	30 83       	st	Z, r19
 556:	31 97       	sbiw	r30, 0x01	; 1
 558:	38 e1       	ldi	r19, 0x18	; 24
 55a:	30 83       	st	Z, r19
 55c:	31 97       	sbiw	r30, 0x01	; 1
 55e:	39 e1       	ldi	r19, 0x19	; 25
 560:	30 83       	st	Z, r19
 562:	31 97       	sbiw	r30, 0x01	; 1
 564:	30 e2       	ldi	r19, 0x20	; 32
 566:	30 83       	st	Z, r19
 568:	31 97       	sbiw	r30, 0x01	; 1
 56a:	31 e2       	ldi	r19, 0x21	; 33
 56c:	30 83       	st	Z, r19
 56e:	31 97       	sbiw	r30, 0x01	; 1
 570:	20 83       	st	Z, r18
 572:	31 97       	sbiw	r30, 0x01	; 1
 574:	23 e2       	ldi	r18, 0x23	; 35
 576:	20 83       	st	Z, r18
 578:	31 97       	sbiw	r30, 0x01	; 1
 57a:	40 83       	st	Z, r20
 57c:	31 97       	sbiw	r30, 0x01	; 1
 57e:	50 83       	st	Z, r21
 580:	31 97       	sbiw	r30, 0x01	; 1
 582:	26 e2       	ldi	r18, 0x26	; 38
 584:	20 83       	st	Z, r18
 586:	31 97       	sbiw	r30, 0x01	; 1
 588:	27 e2       	ldi	r18, 0x27	; 39
 58a:	20 83       	st	Z, r18
 58c:	31 97       	sbiw	r30, 0x01	; 1
 58e:	28 e2       	ldi	r18, 0x28	; 40
 590:	20 83       	st	Z, r18
 592:	31 97       	sbiw	r30, 0x01	; 1
 594:	29 e2       	ldi	r18, 0x29	; 41
 596:	20 83       	st	Z, r18
 598:	31 97       	sbiw	r30, 0x01	; 1
 59a:	20 e3       	ldi	r18, 0x30	; 48
 59c:	20 83       	st	Z, r18
 59e:	31 97       	sbiw	r30, 0x01	; 1
 5a0:	21 e3       	ldi	r18, 0x31	; 49
 5a2:	20 83       	st	Z, r18
 5a4:	86 97       	sbiw	r24, 0x26	; 38
 5a6:	08 95       	ret

000005a8 <xPortStartScheduler>:
 5a8:	1b bc       	out	0x2b, r1	; 43
 5aa:	8c e7       	ldi	r24, 0x7C	; 124
 5ac:	8a bd       	out	0x2a, r24	; 42
 5ae:	8b e0       	ldi	r24, 0x0B	; 11
 5b0:	8e bd       	out	0x2e, r24	; 46
 5b2:	89 b7       	in	r24, 0x39	; 57
 5b4:	80 61       	ori	r24, 0x10	; 16
 5b6:	89 bf       	out	0x39, r24	; 57
 5b8:	a0 91 27 03 	lds	r26, 0x0327	; 0x800327 <pxCurrentTCB>
 5bc:	b0 91 28 03 	lds	r27, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 5c0:	cd 91       	ld	r28, X+
 5c2:	cd bf       	out	0x3d, r28	; 61
 5c4:	dd 91       	ld	r29, X+
 5c6:	de bf       	out	0x3e, r29	; 62
 5c8:	ff 91       	pop	r31
 5ca:	ef 91       	pop	r30
 5cc:	df 91       	pop	r29
 5ce:	cf 91       	pop	r28
 5d0:	bf 91       	pop	r27
 5d2:	af 91       	pop	r26
 5d4:	9f 91       	pop	r25
 5d6:	8f 91       	pop	r24
 5d8:	7f 91       	pop	r23
 5da:	6f 91       	pop	r22
 5dc:	5f 91       	pop	r21
 5de:	4f 91       	pop	r20
 5e0:	3f 91       	pop	r19
 5e2:	2f 91       	pop	r18
 5e4:	1f 91       	pop	r17
 5e6:	0f 91       	pop	r16
 5e8:	ff 90       	pop	r15
 5ea:	ef 90       	pop	r14
 5ec:	df 90       	pop	r13
 5ee:	cf 90       	pop	r12
 5f0:	bf 90       	pop	r11
 5f2:	af 90       	pop	r10
 5f4:	9f 90       	pop	r9
 5f6:	8f 90       	pop	r8
 5f8:	7f 90       	pop	r7
 5fa:	6f 90       	pop	r6
 5fc:	5f 90       	pop	r5
 5fe:	4f 90       	pop	r4
 600:	3f 90       	pop	r3
 602:	2f 90       	pop	r2
 604:	1f 90       	pop	r1
 606:	0f 90       	pop	r0
 608:	0f be       	out	0x3f, r0	; 63
 60a:	0f 90       	pop	r0
 60c:	08 95       	ret
 60e:	81 e0       	ldi	r24, 0x01	; 1
 610:	08 95       	ret

00000612 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 612:	0f 92       	push	r0
 614:	0f b6       	in	r0, 0x3f	; 63
 616:	f8 94       	cli
 618:	0f 92       	push	r0
 61a:	1f 92       	push	r1
 61c:	11 24       	eor	r1, r1
 61e:	2f 92       	push	r2
 620:	3f 92       	push	r3
 622:	4f 92       	push	r4
 624:	5f 92       	push	r5
 626:	6f 92       	push	r6
 628:	7f 92       	push	r7
 62a:	8f 92       	push	r8
 62c:	9f 92       	push	r9
 62e:	af 92       	push	r10
 630:	bf 92       	push	r11
 632:	cf 92       	push	r12
 634:	df 92       	push	r13
 636:	ef 92       	push	r14
 638:	ff 92       	push	r15
 63a:	0f 93       	push	r16
 63c:	1f 93       	push	r17
 63e:	2f 93       	push	r18
 640:	3f 93       	push	r19
 642:	4f 93       	push	r20
 644:	5f 93       	push	r21
 646:	6f 93       	push	r22
 648:	7f 93       	push	r23
 64a:	8f 93       	push	r24
 64c:	9f 93       	push	r25
 64e:	af 93       	push	r26
 650:	bf 93       	push	r27
 652:	cf 93       	push	r28
 654:	df 93       	push	r29
 656:	ef 93       	push	r30
 658:	ff 93       	push	r31
 65a:	a0 91 27 03 	lds	r26, 0x0327	; 0x800327 <pxCurrentTCB>
 65e:	b0 91 28 03 	lds	r27, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 662:	0d b6       	in	r0, 0x3d	; 61
 664:	0d 92       	st	X+, r0
 666:	0e b6       	in	r0, 0x3e	; 62
 668:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 66a:	0e 94 08 07 	call	0xe10	; 0xe10 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 66e:	a0 91 27 03 	lds	r26, 0x0327	; 0x800327 <pxCurrentTCB>
 672:	b0 91 28 03 	lds	r27, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 676:	cd 91       	ld	r28, X+
 678:	cd bf       	out	0x3d, r28	; 61
 67a:	dd 91       	ld	r29, X+
 67c:	de bf       	out	0x3e, r29	; 62
 67e:	ff 91       	pop	r31
 680:	ef 91       	pop	r30
 682:	df 91       	pop	r29
 684:	cf 91       	pop	r28
 686:	bf 91       	pop	r27
 688:	af 91       	pop	r26
 68a:	9f 91       	pop	r25
 68c:	8f 91       	pop	r24
 68e:	7f 91       	pop	r23
 690:	6f 91       	pop	r22
 692:	5f 91       	pop	r21
 694:	4f 91       	pop	r20
 696:	3f 91       	pop	r19
 698:	2f 91       	pop	r18
 69a:	1f 91       	pop	r17
 69c:	0f 91       	pop	r16
 69e:	ff 90       	pop	r15
 6a0:	ef 90       	pop	r14
 6a2:	df 90       	pop	r13
 6a4:	cf 90       	pop	r12
 6a6:	bf 90       	pop	r11
 6a8:	af 90       	pop	r10
 6aa:	9f 90       	pop	r9
 6ac:	8f 90       	pop	r8
 6ae:	7f 90       	pop	r7
 6b0:	6f 90       	pop	r6
 6b2:	5f 90       	pop	r5
 6b4:	4f 90       	pop	r4
 6b6:	3f 90       	pop	r3
 6b8:	2f 90       	pop	r2
 6ba:	1f 90       	pop	r1
 6bc:	0f 90       	pop	r0
 6be:	0f be       	out	0x3f, r0	; 63
 6c0:	0f 90       	pop	r0

	asm volatile ( "ret" );
 6c2:	08 95       	ret

000006c4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 6c4:	0f 92       	push	r0
 6c6:	0f b6       	in	r0, 0x3f	; 63
 6c8:	f8 94       	cli
 6ca:	0f 92       	push	r0
 6cc:	1f 92       	push	r1
 6ce:	11 24       	eor	r1, r1
 6d0:	2f 92       	push	r2
 6d2:	3f 92       	push	r3
 6d4:	4f 92       	push	r4
 6d6:	5f 92       	push	r5
 6d8:	6f 92       	push	r6
 6da:	7f 92       	push	r7
 6dc:	8f 92       	push	r8
 6de:	9f 92       	push	r9
 6e0:	af 92       	push	r10
 6e2:	bf 92       	push	r11
 6e4:	cf 92       	push	r12
 6e6:	df 92       	push	r13
 6e8:	ef 92       	push	r14
 6ea:	ff 92       	push	r15
 6ec:	0f 93       	push	r16
 6ee:	1f 93       	push	r17
 6f0:	2f 93       	push	r18
 6f2:	3f 93       	push	r19
 6f4:	4f 93       	push	r20
 6f6:	5f 93       	push	r21
 6f8:	6f 93       	push	r22
 6fa:	7f 93       	push	r23
 6fc:	8f 93       	push	r24
 6fe:	9f 93       	push	r25
 700:	af 93       	push	r26
 702:	bf 93       	push	r27
 704:	cf 93       	push	r28
 706:	df 93       	push	r29
 708:	ef 93       	push	r30
 70a:	ff 93       	push	r31
 70c:	a0 91 27 03 	lds	r26, 0x0327	; 0x800327 <pxCurrentTCB>
 710:	b0 91 28 03 	lds	r27, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 714:	0d b6       	in	r0, 0x3d	; 61
 716:	0d 92       	st	X+, r0
 718:	0e b6       	in	r0, 0x3e	; 62
 71a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 71c:	0e 94 b2 05 	call	0xb64	; 0xb64 <xTaskIncrementTick>
 720:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 722:	0e 94 08 07 	call	0xe10	; 0xe10 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 726:	a0 91 27 03 	lds	r26, 0x0327	; 0x800327 <pxCurrentTCB>
 72a:	b0 91 28 03 	lds	r27, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 72e:	cd 91       	ld	r28, X+
 730:	cd bf       	out	0x3d, r28	; 61
 732:	dd 91       	ld	r29, X+
 734:	de bf       	out	0x3e, r29	; 62
 736:	ff 91       	pop	r31
 738:	ef 91       	pop	r30
 73a:	df 91       	pop	r29
 73c:	cf 91       	pop	r28
 73e:	bf 91       	pop	r27
 740:	af 91       	pop	r26
 742:	9f 91       	pop	r25
 744:	8f 91       	pop	r24
 746:	7f 91       	pop	r23
 748:	6f 91       	pop	r22
 74a:	5f 91       	pop	r21
 74c:	4f 91       	pop	r20
 74e:	3f 91       	pop	r19
 750:	2f 91       	pop	r18
 752:	1f 91       	pop	r17
 754:	0f 91       	pop	r16
 756:	ff 90       	pop	r15
 758:	ef 90       	pop	r14
 75a:	df 90       	pop	r13
 75c:	cf 90       	pop	r12
 75e:	bf 90       	pop	r11
 760:	af 90       	pop	r10
 762:	9f 90       	pop	r9
 764:	8f 90       	pop	r8
 766:	7f 90       	pop	r7
 768:	6f 90       	pop	r6
 76a:	5f 90       	pop	r5
 76c:	4f 90       	pop	r4
 76e:	3f 90       	pop	r3
 770:	2f 90       	pop	r2
 772:	1f 90       	pop	r1
 774:	0f 90       	pop	r0
 776:	0f be       	out	0x3f, r0	; 63
 778:	0f 90       	pop	r0

	asm volatile ( "ret" );
 77a:	08 95       	ret

0000077c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 77c:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vPortYieldFromTick>
		asm volatile ( "reti" );
 780:	18 95       	reti

00000782 <prvResetNextTaskUnblockTime>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
 782:	e0 91 ef 02 	lds	r30, 0x02EF	; 0x8002ef <pxDelayedTaskList>
 786:	f0 91 f0 02 	lds	r31, 0x02F0	; 0x8002f0 <pxDelayedTaskList+0x1>
 78a:	80 81       	ld	r24, Z
 78c:	81 11       	cpse	r24, r1
 78e:	07 c0       	rjmp	.+14     	; 0x79e <prvResetNextTaskUnblockTime+0x1c>
 790:	8f ef       	ldi	r24, 0xFF	; 255
 792:	9f ef       	ldi	r25, 0xFF	; 255
 794:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
 798:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
 79c:	08 95       	ret
 79e:	e0 91 ef 02 	lds	r30, 0x02EF	; 0x8002ef <pxDelayedTaskList>
 7a2:	f0 91 f0 02 	lds	r31, 0x02F0	; 0x8002f0 <pxDelayedTaskList+0x1>
 7a6:	05 80       	ldd	r0, Z+5	; 0x05
 7a8:	f6 81       	ldd	r31, Z+6	; 0x06
 7aa:	e0 2d       	mov	r30, r0
 7ac:	06 80       	ldd	r0, Z+6	; 0x06
 7ae:	f7 81       	ldd	r31, Z+7	; 0x07
 7b0:	e0 2d       	mov	r30, r0
 7b2:	82 81       	ldd	r24, Z+2	; 0x02
 7b4:	93 81       	ldd	r25, Z+3	; 0x03
 7b6:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
 7ba:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
 7be:	08 95       	ret

000007c0 <prvIdleTask>:
 7c0:	0b ed       	ldi	r16, 0xDB	; 219
 7c2:	12 e0       	ldi	r17, 0x02	; 2
 7c4:	0f 2e       	mov	r0, r31
 7c6:	f3 e0       	ldi	r31, 0x03	; 3
 7c8:	ef 2e       	mov	r14, r31
 7ca:	f3 e0       	ldi	r31, 0x03	; 3
 7cc:	ff 2e       	mov	r15, r31
 7ce:	f0 2d       	mov	r31, r0
 7d0:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <uxDeletedTasksWaitingCleanUp>
 7d4:	88 23       	and	r24, r24
 7d6:	29 f1       	breq	.+74     	; 0x822 <prvIdleTask+0x62>
 7d8:	0f b6       	in	r0, 0x3f	; 63
 7da:	f8 94       	cli
 7dc:	0f 92       	push	r0
 7de:	d8 01       	movw	r26, r16
 7e0:	15 96       	adiw	r26, 0x05	; 5
 7e2:	ed 91       	ld	r30, X+
 7e4:	fc 91       	ld	r31, X
 7e6:	16 97       	sbiw	r26, 0x06	; 6
 7e8:	c6 81       	ldd	r28, Z+6	; 0x06
 7ea:	d7 81       	ldd	r29, Z+7	; 0x07
 7ec:	ce 01       	movw	r24, r28
 7ee:	02 96       	adiw	r24, 0x02	; 2
 7f0:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <uxListRemove>
 7f4:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <uxCurrentNumberOfTasks>
 7f8:	81 50       	subi	r24, 0x01	; 1
 7fa:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <uxCurrentNumberOfTasks>
 7fe:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <uxDeletedTasksWaitingCleanUp>
 802:	81 50       	subi	r24, 0x01	; 1
 804:	80 93 da 02 	sts	0x02DA, r24	; 0x8002da <uxDeletedTasksWaitingCleanUp>
 808:	0f 90       	pop	r0
 80a:	0f be       	out	0x3f, r0	; 63
 80c:	8f 89       	ldd	r24, Y+23	; 0x17
 80e:	98 8d       	ldd	r25, Y+24	; 0x18
 810:	0e 94 87 01 	call	0x30e	; 0x30e <vPortFree>
 814:	ce 01       	movw	r24, r28
 816:	0e 94 87 01 	call	0x30e	; 0x30e <vPortFree>
 81a:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <uxDeletedTasksWaitingCleanUp>
 81e:	81 11       	cpse	r24, r1
 820:	db cf       	rjmp	.-74     	; 0x7d8 <prvIdleTask+0x18>
 822:	f7 01       	movw	r30, r14
 824:	80 81       	ld	r24, Z
 826:	82 30       	cpi	r24, 0x02	; 2
 828:	98 f2       	brcs	.-90     	; 0x7d0 <prvIdleTask+0x10>
 82a:	0e 94 09 03 	call	0x612	; 0x612 <vPortYield>
 82e:	d0 cf       	rjmp	.-96     	; 0x7d0 <prvIdleTask+0x10>

00000830 <prvAddCurrentTaskToDelayedList>:
 830:	ff 92       	push	r15
 832:	0f 93       	push	r16
 834:	1f 93       	push	r17
 836:	cf 93       	push	r28
 838:	df 93       	push	r29
 83a:	ec 01       	movw	r28, r24
 83c:	f6 2e       	mov	r15, r22
 83e:	00 91 ce 02 	lds	r16, 0x02CE	; 0x8002ce <xTickCount>
 842:	10 91 cf 02 	lds	r17, 0x02CF	; 0x8002cf <xTickCount+0x1>
 846:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <pxCurrentTCB>
 84a:	90 91 28 03 	lds	r25, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 84e:	02 96       	adiw	r24, 0x02	; 2
 850:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <uxListRemove>
 854:	cf 3f       	cpi	r28, 0xFF	; 255
 856:	8f ef       	ldi	r24, 0xFF	; 255
 858:	d8 07       	cpc	r29, r24
 85a:	69 f4       	brne	.+26     	; 0x876 <__stack+0x17>
 85c:	ff 20       	and	r15, r15
 85e:	59 f0       	breq	.+22     	; 0x876 <__stack+0x17>
 860:	60 91 27 03 	lds	r22, 0x0327	; 0x800327 <pxCurrentTCB>
 864:	70 91 28 03 	lds	r23, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 868:	6e 5f       	subi	r22, 0xFE	; 254
 86a:	7f 4f       	sbci	r23, 0xFF	; 255
 86c:	81 ed       	ldi	r24, 0xD1	; 209
 86e:	92 e0       	ldi	r25, 0x02	; 2
 870:	0e 94 9a 01 	call	0x334	; 0x334 <vListInsertEnd>
 874:	2f c0       	rjmp	.+94     	; 0x8d4 <__stack+0x75>
 876:	c0 0f       	add	r28, r16
 878:	d1 1f       	adc	r29, r17
 87a:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <pxCurrentTCB>
 87e:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 882:	d3 83       	std	Z+3, r29	; 0x03
 884:	c2 83       	std	Z+2, r28	; 0x02
 886:	c0 17       	cp	r28, r16
 888:	d1 07       	cpc	r29, r17
 88a:	68 f4       	brcc	.+26     	; 0x8a6 <__stack+0x47>
 88c:	60 91 27 03 	lds	r22, 0x0327	; 0x800327 <pxCurrentTCB>
 890:	70 91 28 03 	lds	r23, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 894:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <pxOverflowDelayedTaskList>
 898:	90 91 ee 02 	lds	r25, 0x02EE	; 0x8002ee <pxOverflowDelayedTaskList+0x1>
 89c:	6e 5f       	subi	r22, 0xFE	; 254
 89e:	7f 4f       	sbci	r23, 0xFF	; 255
 8a0:	0e 94 bb 01 	call	0x376	; 0x376 <vListInsert>
 8a4:	17 c0       	rjmp	.+46     	; 0x8d4 <__stack+0x75>
 8a6:	60 91 27 03 	lds	r22, 0x0327	; 0x800327 <pxCurrentTCB>
 8aa:	70 91 28 03 	lds	r23, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 8ae:	80 91 ef 02 	lds	r24, 0x02EF	; 0x8002ef <pxDelayedTaskList>
 8b2:	90 91 f0 02 	lds	r25, 0x02F0	; 0x8002f0 <pxDelayedTaskList+0x1>
 8b6:	6e 5f       	subi	r22, 0xFE	; 254
 8b8:	7f 4f       	sbci	r23, 0xFF	; 255
 8ba:	0e 94 bb 01 	call	0x376	; 0x376 <vListInsert>
 8be:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <xNextTaskUnblockTime>
 8c2:	90 91 c6 02 	lds	r25, 0x02C6	; 0x8002c6 <xNextTaskUnblockTime+0x1>
 8c6:	c8 17       	cp	r28, r24
 8c8:	d9 07       	cpc	r29, r25
 8ca:	20 f4       	brcc	.+8      	; 0x8d4 <__stack+0x75>
 8cc:	d0 93 c6 02 	sts	0x02C6, r29	; 0x8002c6 <xNextTaskUnblockTime+0x1>
 8d0:	c0 93 c5 02 	sts	0x02C5, r28	; 0x8002c5 <xNextTaskUnblockTime>
 8d4:	df 91       	pop	r29
 8d6:	cf 91       	pop	r28
 8d8:	1f 91       	pop	r17
 8da:	0f 91       	pop	r16
 8dc:	ff 90       	pop	r15
 8de:	08 95       	ret

000008e0 <xTaskCreate>:
 8e0:	4f 92       	push	r4
 8e2:	5f 92       	push	r5
 8e4:	6f 92       	push	r6
 8e6:	7f 92       	push	r7
 8e8:	8f 92       	push	r8
 8ea:	9f 92       	push	r9
 8ec:	af 92       	push	r10
 8ee:	bf 92       	push	r11
 8f0:	cf 92       	push	r12
 8f2:	df 92       	push	r13
 8f4:	ef 92       	push	r14
 8f6:	ff 92       	push	r15
 8f8:	0f 93       	push	r16
 8fa:	cf 93       	push	r28
 8fc:	df 93       	push	r29
 8fe:	4c 01       	movw	r8, r24
 900:	6b 01       	movw	r12, r22
 902:	5a 01       	movw	r10, r20
 904:	29 01       	movw	r4, r18
 906:	ca 01       	movw	r24, r20
 908:	0e 94 52 01 	call	0x2a4	; 0x2a4 <pvPortMalloc>
 90c:	3c 01       	movw	r6, r24
 90e:	89 2b       	or	r24, r25
 910:	09 f4       	brne	.+2      	; 0x914 <xTaskCreate+0x34>
 912:	e7 c0       	rjmp	.+462    	; 0xae2 <xTaskCreate+0x202>
 914:	86 e2       	ldi	r24, 0x26	; 38
 916:	90 e0       	ldi	r25, 0x00	; 0
 918:	0e 94 52 01 	call	0x2a4	; 0x2a4 <pvPortMalloc>
 91c:	ec 01       	movw	r28, r24
 91e:	89 2b       	or	r24, r25
 920:	59 f0       	breq	.+22     	; 0x938 <xTaskCreate+0x58>
 922:	78 8e       	std	Y+24, r7	; 0x18
 924:	6f 8a       	std	Y+23, r6	; 0x17
 926:	81 e0       	ldi	r24, 0x01	; 1
 928:	a8 1a       	sub	r10, r24
 92a:	b1 08       	sbc	r11, r1
 92c:	a6 0c       	add	r10, r6
 92e:	b7 1c       	adc	r11, r7
 930:	c1 14       	cp	r12, r1
 932:	d1 04       	cpc	r13, r1
 934:	29 f4       	brne	.+10     	; 0x940 <xTaskCreate+0x60>
 936:	20 c0       	rjmp	.+64     	; 0x978 <xTaskCreate+0x98>
 938:	c3 01       	movw	r24, r6
 93a:	0e 94 87 01 	call	0x30e	; 0x30e <vPortFree>
 93e:	d1 c0       	rjmp	.+418    	; 0xae2 <xTaskCreate+0x202>
 940:	d6 01       	movw	r26, r12
 942:	8c 91       	ld	r24, X
 944:	89 8f       	std	Y+25, r24	; 0x19
 946:	8c 91       	ld	r24, X
 948:	88 23       	and	r24, r24
 94a:	a1 f0       	breq	.+40     	; 0x974 <xTaskCreate+0x94>
 94c:	ae 01       	movw	r20, r28
 94e:	46 5e       	subi	r20, 0xE6	; 230
 950:	5f 4f       	sbci	r21, 0xFF	; 255
 952:	f6 01       	movw	r30, r12
 954:	31 96       	adiw	r30, 0x01	; 1
 956:	b8 e0       	ldi	r27, 0x08	; 8
 958:	cb 0e       	add	r12, r27
 95a:	d1 1c       	adc	r13, r1
 95c:	cf 01       	movw	r24, r30
 95e:	21 91       	ld	r18, Z+
 960:	da 01       	movw	r26, r20
 962:	2d 93       	st	X+, r18
 964:	ad 01       	movw	r20, r26
 966:	dc 01       	movw	r26, r24
 968:	8c 91       	ld	r24, X
 96a:	88 23       	and	r24, r24
 96c:	19 f0       	breq	.+6      	; 0x974 <xTaskCreate+0x94>
 96e:	ec 15       	cp	r30, r12
 970:	fd 05       	cpc	r31, r13
 972:	a1 f7       	brne	.-24     	; 0x95c <xTaskCreate+0x7c>
 974:	18 a2       	std	Y+32, r1	; 0x20
 976:	01 c0       	rjmp	.+2      	; 0x97a <xTaskCreate+0x9a>
 978:	19 8e       	std	Y+25, r1	; 0x19
 97a:	04 30       	cpi	r16, 0x04	; 4
 97c:	08 f0       	brcs	.+2      	; 0x980 <xTaskCreate+0xa0>
 97e:	03 e0       	ldi	r16, 0x03	; 3
 980:	0e 8b       	std	Y+22, r16	; 0x16
 982:	6e 01       	movw	r12, r28
 984:	b2 e0       	ldi	r27, 0x02	; 2
 986:	cb 0e       	add	r12, r27
 988:	d1 1c       	adc	r13, r1
 98a:	c6 01       	movw	r24, r12
 98c:	0e 94 96 01 	call	0x32c	; 0x32c <vListInitialiseItem>
 990:	ce 01       	movw	r24, r28
 992:	0c 96       	adiw	r24, 0x0c	; 12
 994:	0e 94 96 01 	call	0x32c	; 0x32c <vListInitialiseItem>
 998:	d9 87       	std	Y+9, r29	; 0x09
 99a:	c8 87       	std	Y+8, r28	; 0x08
 99c:	84 e0       	ldi	r24, 0x04	; 4
 99e:	90 e0       	ldi	r25, 0x00	; 0
 9a0:	80 1b       	sub	r24, r16
 9a2:	91 09       	sbc	r25, r1
 9a4:	9d 87       	std	Y+13, r25	; 0x0d
 9a6:	8c 87       	std	Y+12, r24	; 0x0c
 9a8:	db 8b       	std	Y+19, r29	; 0x13
 9aa:	ca 8b       	std	Y+18, r28	; 0x12
 9ac:	19 a2       	std	Y+33, r1	; 0x21
 9ae:	1a a2       	std	Y+34, r1	; 0x22
 9b0:	1b a2       	std	Y+35, r1	; 0x23
 9b2:	1c a2       	std	Y+36, r1	; 0x24
 9b4:	1d a2       	std	Y+37, r1	; 0x25
 9b6:	a2 01       	movw	r20, r4
 9b8:	b4 01       	movw	r22, r8
 9ba:	c5 01       	movw	r24, r10
 9bc:	0e 94 68 02 	call	0x4d0	; 0x4d0 <pxPortInitialiseStack>
 9c0:	99 83       	std	Y+1, r25	; 0x01
 9c2:	88 83       	st	Y, r24
 9c4:	e1 14       	cp	r14, r1
 9c6:	f1 04       	cpc	r15, r1
 9c8:	19 f0       	breq	.+6      	; 0x9d0 <xTaskCreate+0xf0>
 9ca:	f7 01       	movw	r30, r14
 9cc:	d1 83       	std	Z+1, r29	; 0x01
 9ce:	c0 83       	st	Z, r28
 9d0:	0f b6       	in	r0, 0x3f	; 63
 9d2:	f8 94       	cli
 9d4:	0f 92       	push	r0
 9d6:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <uxCurrentNumberOfTasks>
 9da:	8f 5f       	subi	r24, 0xFF	; 255
 9dc:	80 93 d0 02 	sts	0x02D0, r24	; 0x8002d0 <uxCurrentNumberOfTasks>
 9e0:	80 91 27 03 	lds	r24, 0x0327	; 0x800327 <pxCurrentTCB>
 9e4:	90 91 28 03 	lds	r25, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 9e8:	89 2b       	or	r24, r25
 9ea:	d1 f5       	brne	.+116    	; 0xa60 <xTaskCreate+0x180>
 9ec:	d0 93 28 03 	sts	0x0328, r29	; 0x800328 <pxCurrentTCB+0x1>
 9f0:	c0 93 27 03 	sts	0x0327, r28	; 0x800327 <pxCurrentTCB>
 9f4:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <uxCurrentNumberOfTasks>
 9f8:	81 30       	cpi	r24, 0x01	; 1
 9fa:	09 f0       	breq	.+2      	; 0x9fe <xTaskCreate+0x11e>
 9fc:	41 c0       	rjmp	.+130    	; 0xa80 <xTaskCreate+0x1a0>
 9fe:	83 e0       	ldi	r24, 0x03	; 3
 a00:	93 e0       	ldi	r25, 0x03	; 3
 a02:	0e 94 88 01 	call	0x310	; 0x310 <vListInitialise>
 a06:	8c e0       	ldi	r24, 0x0C	; 12
 a08:	93 e0       	ldi	r25, 0x03	; 3
 a0a:	0e 94 88 01 	call	0x310	; 0x310 <vListInitialise>
 a0e:	85 e1       	ldi	r24, 0x15	; 21
 a10:	93 e0       	ldi	r25, 0x03	; 3
 a12:	0e 94 88 01 	call	0x310	; 0x310 <vListInitialise>
 a16:	8e e1       	ldi	r24, 0x1E	; 30
 a18:	93 e0       	ldi	r25, 0x03	; 3
 a1a:	0e 94 88 01 	call	0x310	; 0x310 <vListInitialise>
 a1e:	8a ef       	ldi	r24, 0xFA	; 250
 a20:	92 e0       	ldi	r25, 0x02	; 2
 a22:	0e 94 88 01 	call	0x310	; 0x310 <vListInitialise>
 a26:	81 ef       	ldi	r24, 0xF1	; 241
 a28:	92 e0       	ldi	r25, 0x02	; 2
 a2a:	0e 94 88 01 	call	0x310	; 0x310 <vListInitialise>
 a2e:	84 ee       	ldi	r24, 0xE4	; 228
 a30:	92 e0       	ldi	r25, 0x02	; 2
 a32:	0e 94 88 01 	call	0x310	; 0x310 <vListInitialise>
 a36:	8b ed       	ldi	r24, 0xDB	; 219
 a38:	92 e0       	ldi	r25, 0x02	; 2
 a3a:	0e 94 88 01 	call	0x310	; 0x310 <vListInitialise>
 a3e:	81 ed       	ldi	r24, 0xD1	; 209
 a40:	92 e0       	ldi	r25, 0x02	; 2
 a42:	0e 94 88 01 	call	0x310	; 0x310 <vListInitialise>
 a46:	8a ef       	ldi	r24, 0xFA	; 250
 a48:	92 e0       	ldi	r25, 0x02	; 2
 a4a:	90 93 f0 02 	sts	0x02F0, r25	; 0x8002f0 <pxDelayedTaskList+0x1>
 a4e:	80 93 ef 02 	sts	0x02EF, r24	; 0x8002ef <pxDelayedTaskList>
 a52:	81 ef       	ldi	r24, 0xF1	; 241
 a54:	92 e0       	ldi	r25, 0x02	; 2
 a56:	90 93 ee 02 	sts	0x02EE, r25	; 0x8002ee <pxOverflowDelayedTaskList+0x1>
 a5a:	80 93 ed 02 	sts	0x02ED, r24	; 0x8002ed <pxOverflowDelayedTaskList>
 a5e:	10 c0       	rjmp	.+32     	; 0xa80 <xTaskCreate+0x1a0>
 a60:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xSchedulerRunning>
 a64:	81 11       	cpse	r24, r1
 a66:	0c c0       	rjmp	.+24     	; 0xa80 <xTaskCreate+0x1a0>
 a68:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <pxCurrentTCB>
 a6c:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 a70:	96 89       	ldd	r25, Z+22	; 0x16
 a72:	8e 89       	ldd	r24, Y+22	; 0x16
 a74:	89 17       	cp	r24, r25
 a76:	20 f0       	brcs	.+8      	; 0xa80 <xTaskCreate+0x1a0>
 a78:	d0 93 28 03 	sts	0x0328, r29	; 0x800328 <pxCurrentTCB+0x1>
 a7c:	c0 93 27 03 	sts	0x0327, r28	; 0x800327 <pxCurrentTCB>
 a80:	80 91 c7 02 	lds	r24, 0x02C7	; 0x8002c7 <uxTaskNumber>
 a84:	8f 5f       	subi	r24, 0xFF	; 255
 a86:	80 93 c7 02 	sts	0x02C7, r24	; 0x8002c7 <uxTaskNumber>
 a8a:	8e 89       	ldd	r24, Y+22	; 0x16
 a8c:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <uxTopReadyPriority>
 a90:	98 17       	cp	r25, r24
 a92:	10 f4       	brcc	.+4      	; 0xa98 <xTaskCreate+0x1b8>
 a94:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <uxTopReadyPriority>
 a98:	90 e0       	ldi	r25, 0x00	; 0
 a9a:	9c 01       	movw	r18, r24
 a9c:	22 0f       	add	r18, r18
 a9e:	33 1f       	adc	r19, r19
 aa0:	22 0f       	add	r18, r18
 aa2:	33 1f       	adc	r19, r19
 aa4:	22 0f       	add	r18, r18
 aa6:	33 1f       	adc	r19, r19
 aa8:	82 0f       	add	r24, r18
 aaa:	93 1f       	adc	r25, r19
 aac:	b6 01       	movw	r22, r12
 aae:	8d 5f       	subi	r24, 0xFD	; 253
 ab0:	9c 4f       	sbci	r25, 0xFC	; 252
 ab2:	0e 94 9a 01 	call	0x334	; 0x334 <vListInsertEnd>
 ab6:	0f 90       	pop	r0
 ab8:	0f be       	out	0x3f, r0	; 63
 aba:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xSchedulerRunning>
 abe:	88 23       	and	r24, r24
 ac0:	61 f0       	breq	.+24     	; 0xada <xTaskCreate+0x1fa>
 ac2:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <pxCurrentTCB>
 ac6:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 aca:	96 89       	ldd	r25, Z+22	; 0x16
 acc:	8e 89       	ldd	r24, Y+22	; 0x16
 ace:	98 17       	cp	r25, r24
 ad0:	30 f4       	brcc	.+12     	; 0xade <xTaskCreate+0x1fe>
 ad2:	0e 94 09 03 	call	0x612	; 0x612 <vPortYield>
 ad6:	81 e0       	ldi	r24, 0x01	; 1
 ad8:	05 c0       	rjmp	.+10     	; 0xae4 <xTaskCreate+0x204>
 ada:	81 e0       	ldi	r24, 0x01	; 1
 adc:	03 c0       	rjmp	.+6      	; 0xae4 <xTaskCreate+0x204>
 ade:	81 e0       	ldi	r24, 0x01	; 1
 ae0:	01 c0       	rjmp	.+2      	; 0xae4 <xTaskCreate+0x204>
 ae2:	8f ef       	ldi	r24, 0xFF	; 255
 ae4:	df 91       	pop	r29
 ae6:	cf 91       	pop	r28
 ae8:	0f 91       	pop	r16
 aea:	ff 90       	pop	r15
 aec:	ef 90       	pop	r14
 aee:	df 90       	pop	r13
 af0:	cf 90       	pop	r12
 af2:	bf 90       	pop	r11
 af4:	af 90       	pop	r10
 af6:	9f 90       	pop	r9
 af8:	8f 90       	pop	r8
 afa:	7f 90       	pop	r7
 afc:	6f 90       	pop	r6
 afe:	5f 90       	pop	r5
 b00:	4f 90       	pop	r4
 b02:	08 95       	ret

00000b04 <vTaskStartScheduler>:
 b04:	ef 92       	push	r14
 b06:	ff 92       	push	r15
 b08:	0f 93       	push	r16
 b0a:	0f 2e       	mov	r0, r31
 b0c:	f3 ec       	ldi	r31, 0xC3	; 195
 b0e:	ef 2e       	mov	r14, r31
 b10:	f2 e0       	ldi	r31, 0x02	; 2
 b12:	ff 2e       	mov	r15, r31
 b14:	f0 2d       	mov	r31, r0
 b16:	00 e0       	ldi	r16, 0x00	; 0
 b18:	20 e0       	ldi	r18, 0x00	; 0
 b1a:	30 e0       	ldi	r19, 0x00	; 0
 b1c:	45 e5       	ldi	r20, 0x55	; 85
 b1e:	50 e0       	ldi	r21, 0x00	; 0
 b20:	60 e6       	ldi	r22, 0x60	; 96
 b22:	70 e0       	ldi	r23, 0x00	; 0
 b24:	80 ee       	ldi	r24, 0xE0	; 224
 b26:	93 e0       	ldi	r25, 0x03	; 3
 b28:	0e 94 70 04 	call	0x8e0	; 0x8e0 <xTaskCreate>
 b2c:	81 30       	cpi	r24, 0x01	; 1
 b2e:	81 f4       	brne	.+32     	; 0xb50 <vTaskStartScheduler+0x4c>
 b30:	f8 94       	cli
 b32:	8f ef       	ldi	r24, 0xFF	; 255
 b34:	9f ef       	ldi	r25, 0xFF	; 255
 b36:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
 b3a:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
 b3e:	81 e0       	ldi	r24, 0x01	; 1
 b40:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xSchedulerRunning>
 b44:	10 92 cf 02 	sts	0x02CF, r1	; 0x8002cf <xTickCount+0x1>
 b48:	10 92 ce 02 	sts	0x02CE, r1	; 0x8002ce <xTickCount>
 b4c:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <xPortStartScheduler>
 b50:	0f 91       	pop	r16
 b52:	ff 90       	pop	r15
 b54:	ef 90       	pop	r14
 b56:	08 95       	ret

00000b58 <vTaskSuspendAll>:
 b58:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
 b5c:	8f 5f       	subi	r24, 0xFF	; 255
 b5e:	80 93 c2 02 	sts	0x02C2, r24	; 0x8002c2 <uxSchedulerSuspended>
 b62:	08 95       	ret

00000b64 <xTaskIncrementTick>:
 b64:	cf 92       	push	r12
 b66:	df 92       	push	r13
 b68:	ef 92       	push	r14
 b6a:	ff 92       	push	r15
 b6c:	0f 93       	push	r16
 b6e:	1f 93       	push	r17
 b70:	cf 93       	push	r28
 b72:	df 93       	push	r29
 b74:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
 b78:	81 11       	cpse	r24, r1
 b7a:	9f c0       	rjmp	.+318    	; 0xcba <xTaskIncrementTick+0x156>
 b7c:	e0 90 ce 02 	lds	r14, 0x02CE	; 0x8002ce <xTickCount>
 b80:	f0 90 cf 02 	lds	r15, 0x02CF	; 0x8002cf <xTickCount+0x1>
 b84:	8f ef       	ldi	r24, 0xFF	; 255
 b86:	e8 1a       	sub	r14, r24
 b88:	f8 0a       	sbc	r15, r24
 b8a:	f0 92 cf 02 	sts	0x02CF, r15	; 0x8002cf <xTickCount+0x1>
 b8e:	e0 92 ce 02 	sts	0x02CE, r14	; 0x8002ce <xTickCount>
 b92:	e1 14       	cp	r14, r1
 b94:	f1 04       	cpc	r15, r1
 b96:	b9 f4       	brne	.+46     	; 0xbc6 <xTaskIncrementTick+0x62>
 b98:	80 91 ef 02 	lds	r24, 0x02EF	; 0x8002ef <pxDelayedTaskList>
 b9c:	90 91 f0 02 	lds	r25, 0x02F0	; 0x8002f0 <pxDelayedTaskList+0x1>
 ba0:	20 91 ed 02 	lds	r18, 0x02ED	; 0x8002ed <pxOverflowDelayedTaskList>
 ba4:	30 91 ee 02 	lds	r19, 0x02EE	; 0x8002ee <pxOverflowDelayedTaskList+0x1>
 ba8:	30 93 f0 02 	sts	0x02F0, r19	; 0x8002f0 <pxDelayedTaskList+0x1>
 bac:	20 93 ef 02 	sts	0x02EF, r18	; 0x8002ef <pxDelayedTaskList>
 bb0:	90 93 ee 02 	sts	0x02EE, r25	; 0x8002ee <pxOverflowDelayedTaskList+0x1>
 bb4:	80 93 ed 02 	sts	0x02ED, r24	; 0x8002ed <pxOverflowDelayedTaskList>
 bb8:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <xNumOfOverflows>
 bbc:	8f 5f       	subi	r24, 0xFF	; 255
 bbe:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <xNumOfOverflows>
 bc2:	0e 94 c1 03 	call	0x782	; 0x782 <prvResetNextTaskUnblockTime>
 bc6:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <xNextTaskUnblockTime>
 bca:	90 91 c6 02 	lds	r25, 0x02C6	; 0x8002c6 <xNextTaskUnblockTime+0x1>
 bce:	e8 16       	cp	r14, r24
 bd0:	f9 06       	cpc	r15, r25
 bd2:	10 f4       	brcc	.+4      	; 0xbd8 <xTaskIncrementTick+0x74>
 bd4:	d1 2c       	mov	r13, r1
 bd6:	53 c0       	rjmp	.+166    	; 0xc7e <xTaskIncrementTick+0x11a>
 bd8:	d1 2c       	mov	r13, r1
 bda:	cc 24       	eor	r12, r12
 bdc:	c3 94       	inc	r12
 bde:	e0 91 ef 02 	lds	r30, 0x02EF	; 0x8002ef <pxDelayedTaskList>
 be2:	f0 91 f0 02 	lds	r31, 0x02F0	; 0x8002f0 <pxDelayedTaskList+0x1>
 be6:	80 81       	ld	r24, Z
 be8:	81 11       	cpse	r24, r1
 bea:	07 c0       	rjmp	.+14     	; 0xbfa <xTaskIncrementTick+0x96>
 bec:	8f ef       	ldi	r24, 0xFF	; 255
 bee:	9f ef       	ldi	r25, 0xFF	; 255
 bf0:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
 bf4:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
 bf8:	42 c0       	rjmp	.+132    	; 0xc7e <xTaskIncrementTick+0x11a>
 bfa:	e0 91 ef 02 	lds	r30, 0x02EF	; 0x8002ef <pxDelayedTaskList>
 bfe:	f0 91 f0 02 	lds	r31, 0x02F0	; 0x8002f0 <pxDelayedTaskList+0x1>
 c02:	05 80       	ldd	r0, Z+5	; 0x05
 c04:	f6 81       	ldd	r31, Z+6	; 0x06
 c06:	e0 2d       	mov	r30, r0
 c08:	c6 81       	ldd	r28, Z+6	; 0x06
 c0a:	d7 81       	ldd	r29, Z+7	; 0x07
 c0c:	8a 81       	ldd	r24, Y+2	; 0x02
 c0e:	9b 81       	ldd	r25, Y+3	; 0x03
 c10:	e8 16       	cp	r14, r24
 c12:	f9 06       	cpc	r15, r25
 c14:	28 f4       	brcc	.+10     	; 0xc20 <xTaskIncrementTick+0xbc>
 c16:	90 93 c6 02 	sts	0x02C6, r25	; 0x8002c6 <xNextTaskUnblockTime+0x1>
 c1a:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <xNextTaskUnblockTime>
 c1e:	2f c0       	rjmp	.+94     	; 0xc7e <xTaskIncrementTick+0x11a>
 c20:	8e 01       	movw	r16, r28
 c22:	0e 5f       	subi	r16, 0xFE	; 254
 c24:	1f 4f       	sbci	r17, 0xFF	; 255
 c26:	c8 01       	movw	r24, r16
 c28:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <uxListRemove>
 c2c:	8c 89       	ldd	r24, Y+20	; 0x14
 c2e:	9d 89       	ldd	r25, Y+21	; 0x15
 c30:	89 2b       	or	r24, r25
 c32:	21 f0       	breq	.+8      	; 0xc3c <xTaskIncrementTick+0xd8>
 c34:	ce 01       	movw	r24, r28
 c36:	0c 96       	adiw	r24, 0x0c	; 12
 c38:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <uxListRemove>
 c3c:	8e 89       	ldd	r24, Y+22	; 0x16
 c3e:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <uxTopReadyPriority>
 c42:	98 17       	cp	r25, r24
 c44:	10 f4       	brcc	.+4      	; 0xc4a <xTaskIncrementTick+0xe6>
 c46:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <uxTopReadyPriority>
 c4a:	90 e0       	ldi	r25, 0x00	; 0
 c4c:	9c 01       	movw	r18, r24
 c4e:	22 0f       	add	r18, r18
 c50:	33 1f       	adc	r19, r19
 c52:	22 0f       	add	r18, r18
 c54:	33 1f       	adc	r19, r19
 c56:	22 0f       	add	r18, r18
 c58:	33 1f       	adc	r19, r19
 c5a:	82 0f       	add	r24, r18
 c5c:	93 1f       	adc	r25, r19
 c5e:	b8 01       	movw	r22, r16
 c60:	8d 5f       	subi	r24, 0xFD	; 253
 c62:	9c 4f       	sbci	r25, 0xFC	; 252
 c64:	0e 94 9a 01 	call	0x334	; 0x334 <vListInsertEnd>
 c68:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <pxCurrentTCB>
 c6c:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 c70:	9e 89       	ldd	r25, Y+22	; 0x16
 c72:	86 89       	ldd	r24, Z+22	; 0x16
 c74:	98 17       	cp	r25, r24
 c76:	08 f4       	brcc	.+2      	; 0xc7a <xTaskIncrementTick+0x116>
 c78:	b2 cf       	rjmp	.-156    	; 0xbde <xTaskIncrementTick+0x7a>
 c7a:	dc 2c       	mov	r13, r12
 c7c:	b0 cf       	rjmp	.-160    	; 0xbde <xTaskIncrementTick+0x7a>
 c7e:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <pxCurrentTCB>
 c82:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 c86:	86 89       	ldd	r24, Z+22	; 0x16
 c88:	90 e0       	ldi	r25, 0x00	; 0
 c8a:	fc 01       	movw	r30, r24
 c8c:	ee 0f       	add	r30, r30
 c8e:	ff 1f       	adc	r31, r31
 c90:	ee 0f       	add	r30, r30
 c92:	ff 1f       	adc	r31, r31
 c94:	ee 0f       	add	r30, r30
 c96:	ff 1f       	adc	r31, r31
 c98:	8e 0f       	add	r24, r30
 c9a:	9f 1f       	adc	r25, r31
 c9c:	fc 01       	movw	r30, r24
 c9e:	ed 5f       	subi	r30, 0xFD	; 253
 ca0:	fc 4f       	sbci	r31, 0xFC	; 252
 ca2:	80 81       	ld	r24, Z
 ca4:	82 30       	cpi	r24, 0x02	; 2
 ca6:	10 f0       	brcs	.+4      	; 0xcac <xTaskIncrementTick+0x148>
 ca8:	dd 24       	eor	r13, r13
 caa:	d3 94       	inc	r13
 cac:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <xYieldPending>
 cb0:	88 23       	and	r24, r24
 cb2:	69 f0       	breq	.+26     	; 0xcce <xTaskIncrementTick+0x16a>
 cb4:	dd 24       	eor	r13, r13
 cb6:	d3 94       	inc	r13
 cb8:	0a c0       	rjmp	.+20     	; 0xcce <xTaskIncrementTick+0x16a>
 cba:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <xPendedTicks>
 cbe:	90 91 cb 02 	lds	r25, 0x02CB	; 0x8002cb <xPendedTicks+0x1>
 cc2:	01 96       	adiw	r24, 0x01	; 1
 cc4:	90 93 cb 02 	sts	0x02CB, r25	; 0x8002cb <xPendedTicks+0x1>
 cc8:	80 93 ca 02 	sts	0x02CA, r24	; 0x8002ca <xPendedTicks>
 ccc:	d1 2c       	mov	r13, r1
 cce:	8d 2d       	mov	r24, r13
 cd0:	df 91       	pop	r29
 cd2:	cf 91       	pop	r28
 cd4:	1f 91       	pop	r17
 cd6:	0f 91       	pop	r16
 cd8:	ff 90       	pop	r15
 cda:	ef 90       	pop	r14
 cdc:	df 90       	pop	r13
 cde:	cf 90       	pop	r12
 ce0:	08 95       	ret

00000ce2 <xTaskResumeAll>:
 ce2:	df 92       	push	r13
 ce4:	ef 92       	push	r14
 ce6:	ff 92       	push	r15
 ce8:	0f 93       	push	r16
 cea:	1f 93       	push	r17
 cec:	cf 93       	push	r28
 cee:	df 93       	push	r29
 cf0:	0f b6       	in	r0, 0x3f	; 63
 cf2:	f8 94       	cli
 cf4:	0f 92       	push	r0
 cf6:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
 cfa:	81 50       	subi	r24, 0x01	; 1
 cfc:	80 93 c2 02 	sts	0x02C2, r24	; 0x8002c2 <uxSchedulerSuspended>
 d00:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
 d04:	81 11       	cpse	r24, r1
 d06:	63 c0       	rjmp	.+198    	; 0xdce <xTaskResumeAll+0xec>
 d08:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <uxCurrentNumberOfTasks>
 d0c:	81 11       	cpse	r24, r1
 d0e:	33 c0       	rjmp	.+102    	; 0xd76 <xTaskResumeAll+0x94>
 d10:	61 c0       	rjmp	.+194    	; 0xdd4 <xTaskResumeAll+0xf2>
 d12:	d7 01       	movw	r26, r14
 d14:	15 96       	adiw	r26, 0x05	; 5
 d16:	ed 91       	ld	r30, X+
 d18:	fc 91       	ld	r31, X
 d1a:	16 97       	sbiw	r26, 0x06	; 6
 d1c:	c6 81       	ldd	r28, Z+6	; 0x06
 d1e:	d7 81       	ldd	r29, Z+7	; 0x07
 d20:	ce 01       	movw	r24, r28
 d22:	0c 96       	adiw	r24, 0x0c	; 12
 d24:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <uxListRemove>
 d28:	8e 01       	movw	r16, r28
 d2a:	0e 5f       	subi	r16, 0xFE	; 254
 d2c:	1f 4f       	sbci	r17, 0xFF	; 255
 d2e:	c8 01       	movw	r24, r16
 d30:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <uxListRemove>
 d34:	8e 89       	ldd	r24, Y+22	; 0x16
 d36:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <uxTopReadyPriority>
 d3a:	98 17       	cp	r25, r24
 d3c:	10 f4       	brcc	.+4      	; 0xd42 <xTaskResumeAll+0x60>
 d3e:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <uxTopReadyPriority>
 d42:	90 e0       	ldi	r25, 0x00	; 0
 d44:	9c 01       	movw	r18, r24
 d46:	22 0f       	add	r18, r18
 d48:	33 1f       	adc	r19, r19
 d4a:	22 0f       	add	r18, r18
 d4c:	33 1f       	adc	r19, r19
 d4e:	22 0f       	add	r18, r18
 d50:	33 1f       	adc	r19, r19
 d52:	82 0f       	add	r24, r18
 d54:	93 1f       	adc	r25, r19
 d56:	b8 01       	movw	r22, r16
 d58:	8d 5f       	subi	r24, 0xFD	; 253
 d5a:	9c 4f       	sbci	r25, 0xFC	; 252
 d5c:	0e 94 9a 01 	call	0x334	; 0x334 <vListInsertEnd>
 d60:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <pxCurrentTCB>
 d64:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 d68:	9e 89       	ldd	r25, Y+22	; 0x16
 d6a:	86 89       	ldd	r24, Z+22	; 0x16
 d6c:	98 17       	cp	r25, r24
 d6e:	68 f0       	brcs	.+26     	; 0xd8a <xTaskResumeAll+0xa8>
 d70:	d0 92 c9 02 	sts	0x02C9, r13	; 0x8002c9 <xYieldPending>
 d74:	0a c0       	rjmp	.+20     	; 0xd8a <xTaskResumeAll+0xa8>
 d76:	c0 e0       	ldi	r28, 0x00	; 0
 d78:	d0 e0       	ldi	r29, 0x00	; 0
 d7a:	0f 2e       	mov	r0, r31
 d7c:	f4 ee       	ldi	r31, 0xE4	; 228
 d7e:	ef 2e       	mov	r14, r31
 d80:	f2 e0       	ldi	r31, 0x02	; 2
 d82:	ff 2e       	mov	r15, r31
 d84:	f0 2d       	mov	r31, r0
 d86:	dd 24       	eor	r13, r13
 d88:	d3 94       	inc	r13
 d8a:	f7 01       	movw	r30, r14
 d8c:	80 81       	ld	r24, Z
 d8e:	81 11       	cpse	r24, r1
 d90:	c0 cf       	rjmp	.-128    	; 0xd12 <xTaskResumeAll+0x30>
 d92:	cd 2b       	or	r28, r29
 d94:	11 f0       	breq	.+4      	; 0xd9a <xTaskResumeAll+0xb8>
 d96:	0e 94 c1 03 	call	0x782	; 0x782 <prvResetNextTaskUnblockTime>
 d9a:	c0 91 ca 02 	lds	r28, 0x02CA	; 0x8002ca <xPendedTicks>
 d9e:	d0 91 cb 02 	lds	r29, 0x02CB	; 0x8002cb <xPendedTicks+0x1>
 da2:	20 97       	sbiw	r28, 0x00	; 0
 da4:	61 f0       	breq	.+24     	; 0xdbe <xTaskResumeAll+0xdc>
 da6:	11 e0       	ldi	r17, 0x01	; 1
 da8:	0e 94 b2 05 	call	0xb64	; 0xb64 <xTaskIncrementTick>
 dac:	81 11       	cpse	r24, r1
 dae:	10 93 c9 02 	sts	0x02C9, r17	; 0x8002c9 <xYieldPending>
 db2:	21 97       	sbiw	r28, 0x01	; 1
 db4:	c9 f7       	brne	.-14     	; 0xda8 <xTaskResumeAll+0xc6>
 db6:	10 92 cb 02 	sts	0x02CB, r1	; 0x8002cb <xPendedTicks+0x1>
 dba:	10 92 ca 02 	sts	0x02CA, r1	; 0x8002ca <xPendedTicks>
 dbe:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <xYieldPending>
 dc2:	88 23       	and	r24, r24
 dc4:	31 f0       	breq	.+12     	; 0xdd2 <xTaskResumeAll+0xf0>
 dc6:	0e 94 09 03 	call	0x612	; 0x612 <vPortYield>
 dca:	81 e0       	ldi	r24, 0x01	; 1
 dcc:	03 c0       	rjmp	.+6      	; 0xdd4 <xTaskResumeAll+0xf2>
 dce:	80 e0       	ldi	r24, 0x00	; 0
 dd0:	01 c0       	rjmp	.+2      	; 0xdd4 <xTaskResumeAll+0xf2>
 dd2:	80 e0       	ldi	r24, 0x00	; 0
 dd4:	0f 90       	pop	r0
 dd6:	0f be       	out	0x3f, r0	; 63
 dd8:	df 91       	pop	r29
 dda:	cf 91       	pop	r28
 ddc:	1f 91       	pop	r17
 dde:	0f 91       	pop	r16
 de0:	ff 90       	pop	r15
 de2:	ef 90       	pop	r14
 de4:	df 90       	pop	r13
 de6:	08 95       	ret

00000de8 <vTaskDelay>:
 de8:	cf 93       	push	r28
 dea:	df 93       	push	r29
 dec:	ec 01       	movw	r28, r24
 dee:	89 2b       	or	r24, r25
 df0:	51 f0       	breq	.+20     	; 0xe06 <vTaskDelay+0x1e>
 df2:	0e 94 ac 05 	call	0xb58	; 0xb58 <vTaskSuspendAll>
 df6:	60 e0       	ldi	r22, 0x00	; 0
 df8:	ce 01       	movw	r24, r28
 dfa:	0e 94 18 04 	call	0x830	; 0x830 <prvAddCurrentTaskToDelayedList>
 dfe:	0e 94 71 06 	call	0xce2	; 0xce2 <xTaskResumeAll>
 e02:	81 11       	cpse	r24, r1
 e04:	02 c0       	rjmp	.+4      	; 0xe0a <vTaskDelay+0x22>
 e06:	0e 94 09 03 	call	0x612	; 0x612 <vPortYield>
 e0a:	df 91       	pop	r29
 e0c:	cf 91       	pop	r28
 e0e:	08 95       	ret

00000e10 <vTaskSwitchContext>:
 e10:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <uxSchedulerSuspended>
 e14:	88 23       	and	r24, r24
 e16:	21 f0       	breq	.+8      	; 0xe20 <vTaskSwitchContext+0x10>
 e18:	81 e0       	ldi	r24, 0x01	; 1
 e1a:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xYieldPending>
 e1e:	08 95       	ret
 e20:	10 92 c9 02 	sts	0x02C9, r1	; 0x8002c9 <xYieldPending>
 e24:	20 91 cd 02 	lds	r18, 0x02CD	; 0x8002cd <uxTopReadyPriority>
 e28:	82 2f       	mov	r24, r18
 e2a:	90 e0       	ldi	r25, 0x00	; 0
 e2c:	fc 01       	movw	r30, r24
 e2e:	ee 0f       	add	r30, r30
 e30:	ff 1f       	adc	r31, r31
 e32:	ee 0f       	add	r30, r30
 e34:	ff 1f       	adc	r31, r31
 e36:	ee 0f       	add	r30, r30
 e38:	ff 1f       	adc	r31, r31
 e3a:	e8 0f       	add	r30, r24
 e3c:	f9 1f       	adc	r31, r25
 e3e:	ed 5f       	subi	r30, 0xFD	; 253
 e40:	fc 4f       	sbci	r31, 0xFC	; 252
 e42:	30 81       	ld	r19, Z
 e44:	31 11       	cpse	r19, r1
 e46:	11 c0       	rjmp	.+34     	; 0xe6a <vTaskSwitchContext+0x5a>
 e48:	21 50       	subi	r18, 0x01	; 1
 e4a:	82 2f       	mov	r24, r18
 e4c:	90 e0       	ldi	r25, 0x00	; 0
 e4e:	fc 01       	movw	r30, r24
 e50:	ee 0f       	add	r30, r30
 e52:	ff 1f       	adc	r31, r31
 e54:	ee 0f       	add	r30, r30
 e56:	ff 1f       	adc	r31, r31
 e58:	ee 0f       	add	r30, r30
 e5a:	ff 1f       	adc	r31, r31
 e5c:	e8 0f       	add	r30, r24
 e5e:	f9 1f       	adc	r31, r25
 e60:	ed 5f       	subi	r30, 0xFD	; 253
 e62:	fc 4f       	sbci	r31, 0xFC	; 252
 e64:	30 81       	ld	r19, Z
 e66:	33 23       	and	r19, r19
 e68:	79 f3       	breq	.-34     	; 0xe48 <vTaskSwitchContext+0x38>
 e6a:	ac 01       	movw	r20, r24
 e6c:	44 0f       	add	r20, r20
 e6e:	55 1f       	adc	r21, r21
 e70:	44 0f       	add	r20, r20
 e72:	55 1f       	adc	r21, r21
 e74:	44 0f       	add	r20, r20
 e76:	55 1f       	adc	r21, r21
 e78:	48 0f       	add	r20, r24
 e7a:	59 1f       	adc	r21, r25
 e7c:	da 01       	movw	r26, r20
 e7e:	ad 5f       	subi	r26, 0xFD	; 253
 e80:	bc 4f       	sbci	r27, 0xFC	; 252
 e82:	11 96       	adiw	r26, 0x01	; 1
 e84:	ed 91       	ld	r30, X+
 e86:	fc 91       	ld	r31, X
 e88:	12 97       	sbiw	r26, 0x02	; 2
 e8a:	02 80       	ldd	r0, Z+2	; 0x02
 e8c:	f3 81       	ldd	r31, Z+3	; 0x03
 e8e:	e0 2d       	mov	r30, r0
 e90:	12 96       	adiw	r26, 0x02	; 2
 e92:	fc 93       	st	X, r31
 e94:	ee 93       	st	-X, r30
 e96:	11 97       	sbiw	r26, 0x01	; 1
 e98:	4a 5f       	subi	r20, 0xFA	; 250
 e9a:	5c 4f       	sbci	r21, 0xFC	; 252
 e9c:	e4 17       	cp	r30, r20
 e9e:	f5 07       	cpc	r31, r21
 ea0:	29 f4       	brne	.+10     	; 0xeac <vTaskSwitchContext+0x9c>
 ea2:	42 81       	ldd	r20, Z+2	; 0x02
 ea4:	53 81       	ldd	r21, Z+3	; 0x03
 ea6:	fd 01       	movw	r30, r26
 ea8:	52 83       	std	Z+2, r21	; 0x02
 eaa:	41 83       	std	Z+1, r20	; 0x01
 eac:	fc 01       	movw	r30, r24
 eae:	ee 0f       	add	r30, r30
 eb0:	ff 1f       	adc	r31, r31
 eb2:	ee 0f       	add	r30, r30
 eb4:	ff 1f       	adc	r31, r31
 eb6:	ee 0f       	add	r30, r30
 eb8:	ff 1f       	adc	r31, r31
 eba:	8e 0f       	add	r24, r30
 ebc:	9f 1f       	adc	r25, r31
 ebe:	fc 01       	movw	r30, r24
 ec0:	ed 5f       	subi	r30, 0xFD	; 253
 ec2:	fc 4f       	sbci	r31, 0xFC	; 252
 ec4:	01 80       	ldd	r0, Z+1	; 0x01
 ec6:	f2 81       	ldd	r31, Z+2	; 0x02
 ec8:	e0 2d       	mov	r30, r0
 eca:	86 81       	ldd	r24, Z+6	; 0x06
 ecc:	97 81       	ldd	r25, Z+7	; 0x07
 ece:	90 93 28 03 	sts	0x0328, r25	; 0x800328 <pxCurrentTCB+0x1>
 ed2:	80 93 27 03 	sts	0x0327, r24	; 0x800327 <pxCurrentTCB>
 ed6:	20 93 cd 02 	sts	0x02CD, r18	; 0x8002cd <uxTopReadyPriority>
 eda:	08 95       	ret

00000edc <vTaskPlaceOnUnorderedEventList>:
 edc:	cf 93       	push	r28
 ede:	df 93       	push	r29
 ee0:	ea 01       	movw	r28, r20
 ee2:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <pxCurrentTCB>
 ee6:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 eea:	70 68       	ori	r23, 0x80	; 128
 eec:	75 87       	std	Z+13, r23	; 0x0d
 eee:	64 87       	std	Z+12, r22	; 0x0c
 ef0:	60 91 27 03 	lds	r22, 0x0327	; 0x800327 <pxCurrentTCB>
 ef4:	70 91 28 03 	lds	r23, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 ef8:	64 5f       	subi	r22, 0xF4	; 244
 efa:	7f 4f       	sbci	r23, 0xFF	; 255
 efc:	0e 94 9a 01 	call	0x334	; 0x334 <vListInsertEnd>
 f00:	61 e0       	ldi	r22, 0x01	; 1
 f02:	ce 01       	movw	r24, r28
 f04:	0e 94 18 04 	call	0x830	; 0x830 <prvAddCurrentTaskToDelayedList>
 f08:	df 91       	pop	r29
 f0a:	cf 91       	pop	r28
 f0c:	08 95       	ret

00000f0e <vTaskRemoveFromUnorderedEventList>:
 f0e:	0f 93       	push	r16
 f10:	1f 93       	push	r17
 f12:	cf 93       	push	r28
 f14:	df 93       	push	r29
 f16:	70 68       	ori	r23, 0x80	; 128
 f18:	fc 01       	movw	r30, r24
 f1a:	71 83       	std	Z+1, r23	; 0x01
 f1c:	60 83       	st	Z, r22
 f1e:	c6 81       	ldd	r28, Z+6	; 0x06
 f20:	d7 81       	ldd	r29, Z+7	; 0x07
 f22:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <uxListRemove>
 f26:	8e 01       	movw	r16, r28
 f28:	0e 5f       	subi	r16, 0xFE	; 254
 f2a:	1f 4f       	sbci	r17, 0xFF	; 255
 f2c:	c8 01       	movw	r24, r16
 f2e:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <uxListRemove>
 f32:	8e 89       	ldd	r24, Y+22	; 0x16
 f34:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <uxTopReadyPriority>
 f38:	98 17       	cp	r25, r24
 f3a:	10 f4       	brcc	.+4      	; 0xf40 <vTaskRemoveFromUnorderedEventList+0x32>
 f3c:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <uxTopReadyPriority>
 f40:	90 e0       	ldi	r25, 0x00	; 0
 f42:	9c 01       	movw	r18, r24
 f44:	22 0f       	add	r18, r18
 f46:	33 1f       	adc	r19, r19
 f48:	22 0f       	add	r18, r18
 f4a:	33 1f       	adc	r19, r19
 f4c:	22 0f       	add	r18, r18
 f4e:	33 1f       	adc	r19, r19
 f50:	82 0f       	add	r24, r18
 f52:	93 1f       	adc	r25, r19
 f54:	b8 01       	movw	r22, r16
 f56:	8d 5f       	subi	r24, 0xFD	; 253
 f58:	9c 4f       	sbci	r25, 0xFC	; 252
 f5a:	0e 94 9a 01 	call	0x334	; 0x334 <vListInsertEnd>
 f5e:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <pxCurrentTCB>
 f62:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 f66:	9e 89       	ldd	r25, Y+22	; 0x16
 f68:	86 89       	ldd	r24, Z+22	; 0x16
 f6a:	89 17       	cp	r24, r25
 f6c:	18 f4       	brcc	.+6      	; 0xf74 <vTaskRemoveFromUnorderedEventList+0x66>
 f6e:	81 e0       	ldi	r24, 0x01	; 1
 f70:	80 93 c9 02 	sts	0x02C9, r24	; 0x8002c9 <xYieldPending>
 f74:	df 91       	pop	r29
 f76:	cf 91       	pop	r28
 f78:	1f 91       	pop	r17
 f7a:	0f 91       	pop	r16
 f7c:	08 95       	ret

00000f7e <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 f7e:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <pxCurrentTCB>
 f82:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 f86:	84 85       	ldd	r24, Z+12	; 0x0c
 f88:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 f8a:	e0 91 27 03 	lds	r30, 0x0327	; 0x800327 <pxCurrentTCB>
 f8e:	f0 91 28 03 	lds	r31, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 f92:	a0 91 27 03 	lds	r26, 0x0327	; 0x800327 <pxCurrentTCB>
 f96:	b0 91 28 03 	lds	r27, 0x0328	; 0x800328 <pxCurrentTCB+0x1>
 f9a:	56 96       	adiw	r26, 0x16	; 22
 f9c:	4c 91       	ld	r20, X
 f9e:	24 e0       	ldi	r18, 0x04	; 4
 fa0:	30 e0       	ldi	r19, 0x00	; 0
 fa2:	24 1b       	sub	r18, r20
 fa4:	31 09       	sbc	r19, r1
 fa6:	35 87       	std	Z+13, r19	; 0x0d
 fa8:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
 faa:	08 95       	ret

00000fac <_exit>:
 fac:	f8 94       	cli

00000fae <__stop_program>:
 fae:	ff cf       	rjmp	.-2      	; 0xfae <__stop_program>
